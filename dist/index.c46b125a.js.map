{"mappings":"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","sources":["<anon>","src/cluster.js","src/plugin.js"],"sourcesContent":["/* import G6 from '@antv/g6'; */ const $f030692716f7b8a2$export$85fc379452d91af0 = new G6.Grid();\n// 添加一个搜索框\nconst $f030692716f7b8a2$var$searchInput = document.createElement('input');\n$f030692716f7b8a2$var$searchInput.type = 'text';\ndocument.body.appendChild($f030692716f7b8a2$var$searchInput);\n// 定义搜索函数\nfunction $f030692716f7b8a2$var$searchNodeByLabel(label) {\n    // 查找所有带有指定标签的节点\n    const nodes = graph.findAll('node', (node)=>node.getModel().label === label);\n    // 高亮显示这些节点\n    graph.highlightNodes(nodes.map((node)=>node.getID()));\n}\n// 绑定搜索框事件\n$f030692716f7b8a2$var$searchInput.addEventListener('input', (event)=>{\n    const label = event.target.value;\n    // 调用搜索函数\n    $f030692716f7b8a2$var$searchNodeByLabel(label);\n});\nconst $f030692716f7b8a2$export$4e6f96734dfe12f4 = new G6.Tooltip({\n    offsetX: 20,\n    offsetY: 20,\n    getContent (e) {\n        const outDiv = document.createElement('div');\n        outDiv.style.width = 'auto';\n        outDiv.innerHTML = `\n<ul>\n<li><span class=\"label\">\\u{540D}\\u{79F0}:</span> <span class=\"value\">${e.item.getModel().label}</span></li>\n<li><span class=\"label\">\\u{7C7B}\\u{578B}:</span> <span class=\"value\">${e.item.getModel().category}</span></li>\n</ul>`;\n        return outDiv;\n    },\n    itemTypes: [\n        'node'\n    ]\n});\n\n\n// 获取搜索框和按钮元素\nconst $e87b787498170b8e$var$searchInput = document.getElementById('search-input');\nconst $e87b787498170b8e$var$searchButton = document.getElementById('search-button');\nconst $e87b787498170b8e$var$candidateList = document.createElement('ul');\n$e87b787498170b8e$var$candidateList.className = 'candidate-list';\nconst $e87b787498170b8e$var$searchWrapper = document.querySelector('.search-wrapper');\n$e87b787498170b8e$var$searchWrapper.appendChild($e87b787498170b8e$var$candidateList);\n$e87b787498170b8e$var$searchButton.addEventListener('click', ()=>{\n    const keyword = $e87b787498170b8e$var$searchInput.value; // 获取搜索关键字\n    const nodes = $e87b787498170b8e$var$graph.findAll('node', (node)=>node.getModel().orilabel.includes(keyword) || node.getModel().category === keyword);\n    if (nodes && nodes.length > 0) {\n        const count = nodes.length;\n        console.warn(`\\u{4E00}\\u{5171}\\u{627E}\\u{5230} ${count} \\u{4E2A}\\u{8282}\\u{70B9}.`);\n        nodes.forEach((node)=>{\n            $e87b787498170b8e$var$graph.setItemState(node, 'focus', true); // 设置节点选中状态\n            $e87b787498170b8e$var$graph.focusItem(node); // 将节点居中展开\n        });\n    } else alert(\"\\u6CA1\\u6709\\u627E\\u5230\\u7B26\\u5408\\u6761\\u4EF6\\u7684\\u8282\\u70B9\");\n});\n$e87b787498170b8e$var$candidateList.addEventListener('click', (e)=>{\n    $e87b787498170b8e$var$searchInput.value = e.target.innerHTML;\n    console.log($e87b787498170b8e$var$searchInput.value);\n});\n// 绑定搜索按钮点击事件\n$e87b787498170b8e$var$searchInput.addEventListener('input', ()=>{\n    const keyword = $e87b787498170b8e$var$searchInput.value; // 获取搜索关键字\n    const nodes = $e87b787498170b8e$var$graph.findAll('node', (node)=>node.getModel().orilabel.includes(keyword) || node.getModel().category === keyword);\n    // 清空候选列表\n    $e87b787498170b8e$var$candidateList.innerHTML = '';\n    if (nodes && nodes.length > 0) {\n        nodes.forEach((node)=>{\n            const candidate = document.createElement('li');\n            candidate.className = 'candidate-item';\n            candidate.innerHTML = node.getModel().orilabel;\n            $e87b787498170b8e$var$candidateList.appendChild(candidate);\n        });\n        // 显示候选列表\n        $e87b787498170b8e$var$candidateList.style.display = 'block';\n    } else // 隐藏候选列表\n    $e87b787498170b8e$var$candidateList.style.display = 'none';\n});\n$e87b787498170b8e$var$searchInput.addEventListener('keydown', (event)=>{\n    if (event.key === 'Enter') {\n        const keyword = $e87b787498170b8e$var$searchInput.value; // 获取搜索关键字\n        const nodes = $e87b787498170b8e$var$graph.findAll('node', (node)=>node.getModel().orilabel.includes(keyword) || node.getModel().category === keyword);\n        if (nodes && nodes.length > 0) {\n            const count = nodes.length;\n            alert(`\\u{4E00}\\u{5171}\\u{627E}\\u{5230} ${count} \\u{4E2A}\\u{8282}\\u{70B9}.`);\n            nodes.forEach((node)=>{\n                $e87b787498170b8e$var$graph.setItemState(node, 'focus', true); // 设置节点选中状态\n                $e87b787498170b8e$var$graph.focusItem(node); // 将节点居中展开\n            });\n        } else alert(\"\\u6CA1\\u6709\\u627E\\u5230\\u7B26\\u5408\\u6761\\u4EF6\\u7684\\u8282\\u70B9\");\n    }\n});\nconst { uniqueId: $e87b787498170b8e$var$uniqueId } = G6.Util;\nconst $e87b787498170b8e$var$NODESIZEMAPPING = 'degree';\nconst $e87b787498170b8e$var$SMALLGRAPHLABELMAXLENGTH = 5;\nlet $e87b787498170b8e$var$labelMaxLength = $e87b787498170b8e$var$SMALLGRAPHLABELMAXLENGTH;\n/* const DEFAULTNODESIZE = 20;\r\nconst DEFAULTAGGREGATEDNODESIZE = 53; */ const $e87b787498170b8e$var$NODE_LIMIT = 2000; // TODO: find a proper number for maximum node number on the canvas\nlet $e87b787498170b8e$var$graph = null;\nlet $e87b787498170b8e$var$currentUnproccessedData = {\n    nodes: [],\n    edges: []\n};\nlet $e87b787498170b8e$var$nodeMap = {};\nlet $e87b787498170b8e$var$aggregatedNodeMap = {};\nlet $e87b787498170b8e$var$hiddenItemIds = []; // \b隐藏的元素 id 数组\nlet $e87b787498170b8e$var$largeGraphMode = true;\nlet $e87b787498170b8e$var$cachePositions = {};\nlet $e87b787498170b8e$var$manipulatePosition = undefined;\nlet $e87b787498170b8e$var$descreteNodeCenter;\nlet $e87b787498170b8e$var$layout = {\n    type: '',\n    instance: null,\n    destroyed: true\n};\nlet $e87b787498170b8e$var$expandArray = [];\nlet $e87b787498170b8e$var$collapseArray = [];\nlet $e87b787498170b8e$var$shiftKeydown = false;\nlet $e87b787498170b8e$var$CANVAS_WIDTH = 1000, $e87b787498170b8e$var$CANVAS_HEIGHT = 600;\nconst $e87b787498170b8e$var$duration = 4000;\nconst $e87b787498170b8e$var$animateOpacity = 0.6;\nconst $e87b787498170b8e$var$animateBackOpacity = 0.1;\nconst $e87b787498170b8e$var$virtualEdgeOpacity = 0.1;\nconst $e87b787498170b8e$var$realEdgeOpacity = 0.2;\nconst $e87b787498170b8e$var$darkBackColor = 'rgb(43, 47, 51)';\nconst $e87b787498170b8e$var$disableColor = '#777';\nconst $e87b787498170b8e$var$theme = 'dark';\nconst $e87b787498170b8e$var$subjectColors = [\n    '#0f63a9',\n    '#eb4d4b',\n    'rgba(251, 197, 49,1.0)',\n    '#91cc75',\n    'rgba(156, 136, 255,1.0)',\n    'rgba(127, 143, 166,1.0)'\n];\nconst $e87b787498170b8e$var$colorSets = G6.Util.getColorSetsBySubjectColors($e87b787498170b8e$var$subjectColors, $e87b787498170b8e$var$darkBackColor, $e87b787498170b8e$var$theme, $e87b787498170b8e$var$disableColor);\nconst $e87b787498170b8e$var$global = {\n    node: {\n        style: {\n            fill: '#2B384E'\n        },\n        labelCfg: {\n            style: {\n                fill: '#acaeaf',\n                stroke: '#191b1c'\n            }\n        },\n        stateStyles: {\n            focus: {\n                fill: '#2B384E'\n            },\n            selected: {\n                lineWidth: 10,\n                strokeOpacity: 0.5\n            },\n            activeByLegend: {\n                lineWidth: 10,\n                strokeOpacity: 0.5\n            },\n            inactiveByLegend: {\n                opacity: 0.5\n            }\n        }\n    },\n    edge: {\n        style: {\n            stroke: '#acaeaf',\n            realEdgeStroke: '#acaeaf',\n            realEdgeOpacity: $e87b787498170b8e$var$realEdgeOpacity,\n            strokeOpacity: $e87b787498170b8e$var$realEdgeOpacity\n        },\n        labelCfg: {\n            style: {\n                fill: '#acaeaf',\n                realEdgeStroke: '#acaeaf',\n                realEdgeOpacity: 0.5,\n                stroke: '#191b1c'\n            }\n        },\n        stateStyles: {\n            focus: {\n                stroke: '#fff'\n            }\n        }\n    }\n};\nG6.registerNode(\"\\u805A\\u5408\\u8282\\u70B9\", {\n    draw (cfg, group) {\n        let width = cfg.count * 2, height = cfg.count * 2;\n        const style = cfg.style || {};\n        const colorSet = cfg.colorSet || $e87b787498170b8e$var$colorSets[0];\n        // halo for hover\n        group.addShape('rect', {\n            attrs: {\n                x: -width * 0.6,\n                y: -height * 0.6,\n                width: width * 1.2,\n                height: height * 1.2,\n                fill: colorSet.mainFill,\n                opacity: 0.8,\n                lineWidth: 0.5,\n                radius: (height / 2 || 13) * 1.2\n            },\n            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\n            name: 'halo-shape',\n            visible: false\n        });\n        // focus stroke for hover\n        group.addShape('rect', {\n            attrs: {\n                x: -width * 0.6,\n                y: -height * 0.6,\n                width: width * 1.2,\n                height: height * 1.2,\n                fill: colorSet.mainFill,\n                stroke: 'rgba(245, 246, 250,1.0)',\n                lineWidth: 3,\n                lineOpacty: 0.5,\n                radius: (height / 2 || 13) * 1.2\n            },\n            name: 'stroke-shape',\n            visible: false\n        });\n        const keyShape = group.addShape('rect', {\n            attrs: {\n                ...style,\n                x: -width / 2,\n                y: -height / 2,\n                width: width,\n                height: height,\n                fill: colorSet.mainFill,\n                opacity: 0.2,\n                stroke: colorSet.mainStroke,\n                lineWidth: 4,\n                cursor: 'pointer',\n                radius: height / 2 || 13,\n                lineDash: [\n                    12,\n                    12\n                ]\n            },\n            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\n            name: 'aggregated-node-keyShape'\n        });\n        let labelStyle = {};\n        if (cfg.labelCfg) labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);\n        group.addShape('text', {\n            attrs: {\n                text: cfg.label,\n                x: 0,\n                y: -10,\n                textAlign: 'center',\n                textBaseline: 'middle',\n                cursor: 'pointer',\n                fontSize: 14,\n                fill: 'rgba(245, 246, 250,0.8)',\n                fontWeight: 600\n            },\n            name: 'label-shape',\n            className: 'label-shape'\n        });\n        group.addShape('text', {\n            attrs: {\n                text: `\\u{8282}\\u{70B9}\\u{603B}\\u{6570}\\u{FF1A}${cfg.count + 431}`,\n                x: 0,\n                y: 10,\n                textAlign: 'center',\n                textBaseline: 'middle',\n                cursor: 'pointer',\n                fontSize: 12,\n                fill: 'rgba(220, 221, 225,0.8)',\n                opacity: 0.85,\n                fontWeight: 400\n            },\n            name: 'count-shape',\n            className: 'count-shape',\n            draggable: true\n        });\n        // tag for new node\n        if (cfg.new) group.addShape('circle', {\n            attrs: {\n                x: width / 2 - 3,\n                y: -height / 2 + 3,\n                r: 4,\n                fill: '#6DD400',\n                lineWidth: 0.5,\n                stroke: '#FFFFFF'\n            },\n            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\n            name: 'typeNode-tag-circle'\n        });\n        return keyShape;\n    },\n    setState: (name, value, item)=>{\n        const group = item.get('group');\n        if (name === 'layoutEnd' && value) {\n            const labelShape = group.find((e)=>e.get('name') === 'text-shape');\n            if (labelShape) labelShape.set('visible', true);\n        } else if (name === 'hover') {\n            if (item.hasState('focus')) return;\n            const halo = group.find((e)=>e.get('name') === 'halo-shape');\n            const keyShape = item.getKeyShape();\n            const colorSet = item.getModel().colorSet || $e87b787498170b8e$var$colorSets[0];\n            if (value) {\n                halo && halo.show();\n                keyShape.attr('fill', colorSet.activeFill);\n            } else {\n                halo && halo.hide();\n                keyShape.attr('fill', colorSet.mainFill);\n            }\n        } else if (name === 'focus') {\n            const stroke = group.find((e)=>e.get('name') === 'stroke-shape');\n            const keyShape = item.getKeyShape();\n            const colorSet = item.getModel().colorSet || $e87b787498170b8e$var$colorSets[0];\n            if (value) {\n                stroke && stroke.show();\n                keyShape.attr('fill', colorSet.selectedFill);\n            } else {\n                stroke && stroke.hide();\n                keyShape.attr('fill', colorSet.mainFill);\n            }\n        }\n    },\n    update: undefined\n}, \"\\u805A\\u5408\\u8282\\u70B9\");\nG6.registerNode(\"\\u666E\\u901A\\u8282\\u70B9\", {\n    draw (cfg, group) {\n        const degreeSum = cfg.degree;\n        var r = degreeSum * 1.5 + 5;\n        /*   if (isNumber(cfg.size)) {\r\n                  r = cfg.size / 2;\r\n              } else if (isArray(cfg.size)) {\r\n                  r = cfg.size[0] / 2;\r\n              } */ const style = cfg.style || {};\n        const colorSet = cfg.colorSet || $e87b787498170b8e$var$colorSets[0];\n        // halo for hover\n        group.addShape('circle', {\n            attrs: {\n                x: 0,\n                y: 0,\n                r: r + 5,\n                fill: style.fill || colorSet.mainFill || '#2B384E',\n                opacity: 0.7,\n                lineWidth: 0\n            },\n            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\n            name: 'halo-shape',\n            visible: false\n        });\n        // focus stroke for hover\n        group.addShape('circle', {\n            attrs: {\n                x: 0,\n                y: 0,\n                r: r + 5,\n                fill: style.fill || colorSet.mainFill || '#2B384E',\n                stroke: 'rgba(245, 246, 250,1.0)',\n                strokeOpacity: 0.85,\n                lineWidth: 2\n            },\n            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\n            name: 'stroke-shape',\n            visible: false\n        });\n        const keyShape = group.addShape('circle', {\n            attrs: {\n                ...style,\n                x: 0,\n                y: 0,\n                r: r,\n                fill: colorSet.mainFill,\n                stroke: colorSet.mainStroke,\n                lineWidth: 2,\n                cursor: 'pointer'\n            },\n            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\n            name: 'aggregated-node-keyShape'\n        });\n        let labelStyle = {};\n        if (cfg.labelCfg) labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);\n        if (cfg.label) {\n            const text = cfg.label;\n            let labelStyle = {};\n            let refY = 0;\n            if (cfg.labelCfg) {\n                labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);\n                refY += cfg.labelCfg.refY || 0;\n            }\n            let offsetY = 0;\n            const fontSize = labelStyle.fontSize < 8 ? 8 : labelStyle.fontSize;\n            const lineNum = cfg.labelLineNum || 1;\n            offsetY = lineNum * (fontSize || 12);\n            group.addShape('text', {\n                attrs: {\n                    text: text,\n                    x: 0,\n                    y: r + refY + offsetY + 5,\n                    textAlign: 'center',\n                    textBaseLine: 'alphabetic',\n                    cursor: 'pointer',\n                    fontSize: fontSize,\n                    fill: '#fff',\n                    opacity: 0.85,\n                    fontWeight: 400,\n                    stroke: $e87b787498170b8e$var$global.edge.labelCfg.style.stroke\n                },\n                // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\n                name: 'text-shape',\n                className: 'text-shape'\n            });\n        }\n        // tag for new node\n        if (cfg.new) group.addShape('circle', {\n            attrs: {\n                x: r - 3,\n                y: -r + 3,\n                r: 4,\n                fill: '#6DD400',\n                lineWidth: 0.5,\n                stroke: '#FFFFFF'\n            },\n            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\n            name: 'typeNode-tag-circle'\n        });\n        return keyShape;\n    },\n    setState: (name, value, item)=>{\n        const group = item.get('group');\n        if (name === 'layoutEnd' && value) {\n            const labelShape = group.find((e)=>e.get('name') === 'text-shape');\n            if (labelShape) labelShape.set('visible', true);\n        } else if (name === 'hover') {\n            if (item.hasState('focus')) return;\n            const halo = group.find((e)=>e.get('name') === 'halo-shape');\n            const keyShape = item.getKeyShape();\n            const colorSet = item.getModel().colorSet || $e87b787498170b8e$var$colorSets[0];\n            if (value) {\n                halo && halo.show();\n                keyShape.attr('fill', colorSet.activeFill);\n            } else {\n                halo && halo.hide();\n                keyShape.attr('fill', colorSet.mainFill);\n            }\n        } else if (name === 'focus') {\n            const stroke = group.find((e)=>e.get('name') === 'stroke-shape');\n            const label = group.find((e)=>e.get('name') === 'text-shape');\n            const keyShape = item.getKeyShape();\n            const colorSet = item.getModel().colorSet || $e87b787498170b8e$var$colorSets[0];\n            if (value) {\n                stroke && stroke.show();\n                keyShape.attr('fill', colorSet.selectedFill);\n                label && label.attr('fontWeight', 800);\n            } else {\n                stroke && stroke.hide();\n                keyShape.attr('fill', colorSet.mainFill); // '#2B384E'\n                label && label.attr('fontWeight', 400);\n            }\n        }\n    },\n    update: undefined\n}, \"\\u666E\\u901A\\u8282\\u70B9\"); // 这样可以继承 aggregated-node 的 setState\nG6.registerEdge('ClusterEdge', {\n    setState: (name, value, item)=>{\n        const group = item.get('group');\n        const model = item.getModel();\n        if (name === 'focus') {\n            const back = group.find((ele)=>ele.get('name') === 'back-line');\n            if (back) {\n                back.stopAnimate();\n                back.remove();\n                back.destroy();\n            }\n            const keyShape = group.find((ele)=>ele.get('name') === 'edge-shape');\n            const arrow = model.style.endArrow;\n            if (value) {\n                if (keyShape.cfg.animation) keyShape.stopAnimate(true);\n                keyShape.attr({\n                    strokeOpacity: $e87b787498170b8e$var$animateOpacity,\n                    opacity: $e87b787498170b8e$var$animateOpacity,\n                    stroke: '#fff',\n                    endArrow: {\n                        ...arrow,\n                        stroke: '#fff',\n                        fill: '#fff'\n                    }\n                });\n                if (model.isReal) {\n                    const { lineWidth: lineWidth, path: path, endArrow: endArrow, stroke: stroke } = keyShape.attr();\n                    const back = group.addShape('path', {\n                        attrs: {\n                            lineWidth: lineWidth,\n                            path: path,\n                            stroke: stroke,\n                            endArrow: endArrow,\n                            opacity: $e87b787498170b8e$var$animateBackOpacity\n                        },\n                        // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\n                        name: 'back-line'\n                    });\n                    back.toBack();\n                    const length = keyShape.getTotalLength();\n                    keyShape.animate((ratio)=>{\n                        // the operations in each frame. Ratio ranges from 0 to 1 indicating the prograss of the animation. Returns the modified configurations\n                        const startLen = ratio * length;\n                        // Calculate the lineDash\n                        const cfg = {\n                            lineDash: [\n                                startLen,\n                                length - startLen\n                            ]\n                        };\n                        return cfg;\n                    }, {\n                        repeat: true,\n                        duration: $e87b787498170b8e$var$duration\n                    });\n                } else {\n                    let index = 0;\n                    const lineDash = keyShape.attr('lineDash');\n                    const totalLength = lineDash[0] + lineDash[1];\n                    keyShape.animate(()=>{\n                        index++;\n                        if (index > totalLength) index = 0;\n                        const res = {\n                            lineDash: lineDash,\n                            lineDashOffset: -index\n                        };\n                        // returns the modified configurations here, lineDash and lineDashOffset here\n                        return res;\n                    }, {\n                        repeat: true,\n                        duration: $e87b787498170b8e$var$duration\n                    });\n                }\n            } else {\n                keyShape.stopAnimate();\n                const stroke = '#acaeaf';\n                const opacity = model.isReal ? $e87b787498170b8e$var$realEdgeOpacity : $e87b787498170b8e$var$virtualEdgeOpacity;\n                keyShape.attr({\n                    stroke: stroke,\n                    strokeOpacity: opacity,\n                    opacity: opacity,\n                    endArrow: {\n                        ...arrow,\n                        stroke: stroke,\n                        fill: stroke\n                    }\n                });\n            }\n        }\n    }\n}, 'quadratic');\n// 普通节点边\nG6.registerEdge('NodeEdge', {\n    setState: (name, value, item)=>{\n        const group = item.get('group');\n        const model = item.getModel();\n        if (name === 'focus') {\n            const keyShape = group.find((ele)=>ele.get('name') === 'edge-shape');\n            const back = group.find((ele)=>ele.get('name') === 'back-line');\n            if (back) {\n                back.stopAnimate();\n                back.remove();\n                back.destroy();\n            }\n            const arrow = model.style.endArrow;\n            if (value) {\n                if (keyShape.cfg.animation) keyShape.stopAnimate(true);\n                keyShape.attr({\n                    strokeOpacity: $e87b787498170b8e$var$animateOpacity,\n                    opacity: $e87b787498170b8e$var$animateOpacity,\n                    stroke: '#fff',\n                    endArrow: {\n                        ...arrow,\n                        stroke: '#fff',\n                        fill: '#fff'\n                    }\n                });\n                if (model.isReal) {\n                    const { path: path, stroke: stroke, lineWidth: lineWidth } = keyShape.attr();\n                    const back = group.addShape('path', {\n                        attrs: {\n                            path: path,\n                            stroke: stroke,\n                            lineWidth: lineWidth,\n                            opacity: $e87b787498170b8e$var$animateBackOpacity\n                        },\n                        // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\n                        name: 'back-line'\n                    });\n                    back.toBack();\n                    const length = keyShape.getTotalLength();\n                    keyShape.animate((ratio)=>{\n                        // the operations in each frame. Ratio ranges from 0 to 1 indicating the prograss of the animation. Returns the modified configurations\n                        const startLen = ratio * length;\n                        // Calculate the lineDash\n                        const cfg = {\n                            lineDash: [\n                                startLen,\n                                length - startLen\n                            ]\n                        };\n                        return cfg;\n                    }, {\n                        repeat: true,\n                        duration: $e87b787498170b8e$var$duration\n                    });\n                } else {\n                    const lineDash = keyShape.attr('lineDash');\n                    const totalLength = lineDash[0] + lineDash[1];\n                    let index = 0;\n                    keyShape.animate(()=>{\n                        index++;\n                        if (index > totalLength) index = 0;\n                        const res = {\n                            lineDash: lineDash,\n                            lineDashOffset: -index\n                        };\n                        // returns the modified configurations here, lineDash and lineDashOffset here\n                        return res;\n                    }, {\n                        repeat: true,\n                        duration: $e87b787498170b8e$var$duration\n                    });\n                }\n            } else {\n                keyShape.stopAnimate();\n                const stroke = '#acaeaf';\n                const opacity = model.isReal ? $e87b787498170b8e$var$realEdgeOpacity : $e87b787498170b8e$var$virtualEdgeOpacity;\n                keyShape.attr({\n                    stroke: stroke,\n                    strokeOpacity: opacity,\n                    opacity: opacity,\n                    endArrow: {\n                        ...arrow,\n                        stroke: stroke,\n                        fill: stroke\n                    }\n                });\n            }\n        }\n    }\n}, 'single-edge');\nconst $e87b787498170b8e$var$descendCompare = (p)=>{\n    // 这是比较函数\n    return function(m, n) {\n        const a = m[p];\n        const b = n[p];\n        return b - a; // 降序\n    };\n};\nconst $e87b787498170b8e$var$clearFocusItemState = (graph)=>{\n    if (!graph) return;\n    $e87b787498170b8e$var$clearFocusNodeState(graph);\n    $e87b787498170b8e$var$clearFocusEdgeState(graph);\n};\n// 清除图上所有节点的 focus 状态及相应样式\nconst $e87b787498170b8e$var$clearFocusNodeState = (graph)=>{\n    const focusNodes = graph.findAllByState('node', 'focus');\n    focusNodes.forEach((fnode)=>{\n        graph.setItemState(fnode, 'focus', false); // false\n    });\n};\n// 清除图上所有边的 focus 状态及相应样式\nconst $e87b787498170b8e$var$clearFocusEdgeState = (graph)=>{\n    const focusEdges = graph.findAllByState('edge', 'focus');\n    focusEdges.forEach((fedge)=>{\n        graph.setItemState(fedge, 'focus', false);\n    });\n};\n// 截断长文本。length 为文本截断后长度，elipsis 是后缀\nconst $e87b787498170b8e$var$formatText = (text, length = 5, elipsis = '...')=>{\n    if (!text) return '';\n    if (text.length > length) return `${text.substr(0, length)}${elipsis}`;\n    return text;\n};\nconst $e87b787498170b8e$var$labelFormatter = (text, minLength = 10)=>{\n    if (text && text.split('').length > minLength) return `${text.substr(0, minLength)}...`;\n    return text;\n};\nconst $e87b787498170b8e$var$processNodesEdges = (nodes, edges, width, height, largeGraphMode, edgeLabelVisible, isNewGraph = false)=>{\n    // 如果节点列表为空，则返回空对象\n    if (!nodes || nodes.length === 0) return {};\n    // 定义当前节点的映射表以及最大节点数\n    const currentNodeMap = {};\n    let maxNodeCount = -Infinity;\n    // 定义一些常量\n    const paddingRatio = 0.3;\n    const paddingLeft = paddingRatio * width;\n    const paddingTop = paddingRatio * height;\n    // 对每个节点进行处理\n    nodes.forEach((node)=>{\n        // 设置节点的类型和标签\n        node.type = node.level === 0 ? \"\\u666E\\u901A\\u8282\\u70B9\" : \"\\u805A\\u5408\\u8282\\u70B9\";\n        node.isReal = node.level === 0 ? true : false;\n        /*   node.labelLineNum = undefined; */ node.degree = 0;\n        node.inDegree = 0;\n        node.outDegree = 0;\n        // 防止节点id重复，如果节点id已存在，则在其后添加一个随机数\n        if (currentNodeMap[node.id]) {\n            console.warn('node exists already!', node.id);\n            node.id = `${node.id}${Math.random()}`;\n        }\n        // 将节点加入当前节点映射表中\n        currentNodeMap[node.id] = node;\n        // 计算最大节点数\n        if (node.count > maxNodeCount) maxNodeCount = node.count;\n        // 如果已经有了缓存位置，则使用缓存位置\n        const cachePosition = $e87b787498170b8e$var$cachePositions ? $e87b787498170b8e$var$cachePositions[node.id] : undefined;\n        if (cachePosition) {\n            node.x = cachePosition.x;\n            node.y = cachePosition.y;\n            node.new = false;\n        } else {\n            // 否则随机生成位置\n            node.new = isNewGraph ? false : true;\n            if ($e87b787498170b8e$var$manipulatePosition && !node.x && !node.y) {\n                node.x = $e87b787498170b8e$var$manipulatePosition.x + 10 * Math.cos(Math.random() * Math.PI * 2);\n                node.y = $e87b787498170b8e$var$manipulatePosition.y + 10 * Math.sin(Math.random() * Math.PI * 2);\n            }\n        }\n    });\n    let maxCount = -Infinity;\n    let minCount = Infinity;\n    // let maxCount = 0;\n    edges.forEach((edge)=>{\n        // to avoid the dulplicated id to nodes\n        if (!edge.id) edge.id = $e87b787498170b8e$var$uniqueId('edge');\n        else if (edge.id.split('-')[0] !== 'edge') edge.id = `edge-${edge.id}`;\n        // TODO: delete the following line after the queried data is correct\n        if (!currentNodeMap[edge.source] || !currentNodeMap[edge.target]) {\n            console.warn('edge source target does not exist', edge.source, edge.target, edge.id);\n            return;\n        }\n        const sourceNode = currentNodeMap[edge.source];\n        const targetNode = currentNodeMap[edge.target];\n        if (!sourceNode || !targetNode) console.warn('source or target is not defined!!!', edge, sourceNode, targetNode);\n        // calculate the degree\n        sourceNode.degree++;\n        targetNode.degree++;\n        sourceNode.outDegree++;\n        targetNode.inDegree++;\n        if (edge.count > maxCount) maxCount = edge.count;\n        if (edge.count < minCount) minCount = edge.count;\n    });\n    nodes.sort($e87b787498170b8e$var$descendCompare($e87b787498170b8e$var$NODESIZEMAPPING));\n    const maxDegree = nodes[0].degree || 1;\n    const descreteNodes = [];\n    nodes.forEach((node)=>{\n        // assign the size mapping to the outDegree\n        const countRatio = node.count / maxNodeCount;\n        const isRealNode = node.level === 0;\n        node.size = isRealNode ? (node.degree + 2) * 2 : node.count;\n        node.isReal = isRealNode;\n        node.labelCfg = {\n            position: 'bottom',\n            offset: 5,\n            style: {\n                fill: $e87b787498170b8e$var$global.node.labelCfg.style.fill,\n                fontSize: 6 + countRatio * 6 || 12,\n                stroke: $e87b787498170b8e$var$global.node.labelCfg.style.stroke,\n                lineWidth: 3\n            }\n        };\n        if (!node.degree) descreteNodes.push(node);\n    });\n    const countRange = maxCount - minCount;\n    const minEdgeSize = 1;\n    const maxEdgeSize = 10;\n    const edgeSizeRange = maxEdgeSize - minEdgeSize;\n    edges.forEach((edge)=>{\n        // set edges' style\n        const targetNode = currentNodeMap[edge.target];\n        const size = (edge.count - minCount) / countRange * edgeSizeRange + minEdgeSize || 1;\n        edge.size = size;\n        const arrowWidth = Math.max(size / 2 + 2, 3);\n        const arrowLength = 10;\n        const arrowBeging = targetNode.size + arrowLength;\n        let arrowPath = `M ${arrowBeging},0 L ${arrowBeging + arrowLength},-${arrowWidth} L ${arrowBeging + arrowLength},${arrowWidth} Z`;\n        let d = targetNode.size / 2 + arrowLength;\n        if (edge.source === edge.target) {\n            edge.type = 'loop';\n            arrowPath = undefined;\n        }\n        const sourceNode = currentNodeMap[edge.source];\n        const isRealEdge = targetNode.isReal && sourceNode.isReal;\n        edge.isReal = isRealEdge;\n        const stroke = isRealEdge ? $e87b787498170b8e$var$global.edge.style.realEdgeStroke : $e87b787498170b8e$var$global.edge.style.stroke;\n        const opacity = isRealEdge ? $e87b787498170b8e$var$global.edge.style.realEdgeOpacity : $e87b787498170b8e$var$global.edge.style.strokeOpacity;\n        const dash = Math.max(size, 2);\n        const lineDash = isRealEdge ? undefined : [\n            dash,\n            dash\n        ];\n        edge.style = {\n            stroke: stroke,\n            strokeOpacity: opacity,\n            cursor: 'pointer',\n            lineAppendWidth: Math.max(edge.size || 5, 5),\n            fillOpacity: 1,\n            lineDash: lineDash,\n            endArrow: arrowPath ? {\n                path: arrowPath,\n                d: d,\n                fill: stroke,\n                strokeOpacity: 0\n            } : false\n        };\n        edge.labelCfg = {\n            autoRotate: true,\n            style: {\n                stroke: $e87b787498170b8e$var$global.edge.labelCfg.style.stroke,\n                fill: $e87b787498170b8e$var$global.edge.labelCfg.style.fill,\n                lineWidth: 4,\n                fontSize: 12,\n                lineAppendWidth: 10,\n                opacity: 1\n            }\n        };\n        if (!edge.orilabel) edge.orilabel = edge.label;\n        if (largeGraphMode || !edgeLabelVisible) edge.label = '';\n        else edge.label = $e87b787498170b8e$var$labelFormatter(edge.label, $e87b787498170b8e$var$labelMaxLength);\n        // arrange the other nodes around the hub\n        const sourceDis = sourceNode.size / 2 + 20;\n        const targetDis = targetNode.size / 2 + 20;\n        if (sourceNode.x && !targetNode.x) targetNode.x = sourceNode.x + sourceDis * Math.cos(Math.random() * Math.PI * 2);\n        if (sourceNode.y && !targetNode.y) targetNode.y = sourceNode.y + sourceDis * Math.sin(Math.random() * Math.PI * 2);\n        if (targetNode.x && !sourceNode.x) sourceNode.x = targetNode.x + targetDis * Math.cos(Math.random() * Math.PI * 2);\n        if (targetNode.y && !sourceNode.y) sourceNode.y = targetNode.y + targetDis * Math.sin(Math.random() * Math.PI * 2);\n        if (!sourceNode.x && !sourceNode.y && $e87b787498170b8e$var$manipulatePosition) {\n            sourceNode.x = $e87b787498170b8e$var$manipulatePosition.x + 30 * Math.cos(Math.random() * Math.PI * 2);\n            sourceNode.y = $e87b787498170b8e$var$manipulatePosition.y + 30 * Math.sin(Math.random() * Math.PI * 2);\n        }\n        if (!targetNode.x && !targetNode.y && $e87b787498170b8e$var$manipulatePosition) {\n            targetNode.x = $e87b787498170b8e$var$manipulatePosition.x + 30 * Math.cos(Math.random() * Math.PI * 2);\n            targetNode.y = $e87b787498170b8e$var$manipulatePosition.y + 30 * Math.sin(Math.random() * Math.PI * 2);\n        }\n    });\n    $e87b787498170b8e$var$descreteNodeCenter = {\n        x: width - paddingLeft,\n        y: height - paddingTop\n    };\n    descreteNodes.forEach((node)=>{\n        if (!node.x && !node.y) {\n            node.x = $e87b787498170b8e$var$descreteNodeCenter.x + 30 * Math.cos(Math.random() * Math.PI * 2);\n            node.y = $e87b787498170b8e$var$descreteNodeCenter.y + 30 * Math.sin(Math.random() * Math.PI * 2);\n        }\n    });\n    G6.Util.processParallelEdges(edges, 12.5, 'ClusterEdge', 'NodeEdge');\n    return {\n        maxDegree: maxDegree,\n        edges: edges\n    };\n};\n/**\r\n * 获取 Force 布局的配置信息\r\n * @param graph - G6 图实例对象\r\n * @param largeGraphMode - 是否是大数据量模式\r\n * @param configSettings - 配置项\r\n * @returns {Object} Force 布局的配置对象\r\n */ const $e87b787498170b8e$var$getForceLayoutConfig = (graph, largeGraphMode, configSettings)=>{\n    // 解构出配置项中的参数\n    let { linkDistance: linkDistance, edgeStrength: edgeStrength, nodeStrength: nodeStrength, nodeSpacing: nodeSpacing, preventOverlap: preventOverlap, nodeSize: nodeSize, collideStrength: collideStrength, alpha: alpha, alphaDecay: alphaDecay, alphaMin: alphaMin } = configSettings || {\n        preventOverlap: true\n    };\n    // 若参数未设置，设置默认值\n    if (!linkDistance && linkDistance !== 0) linkDistance = 150;\n    if (!edgeStrength && edgeStrength !== 0) edgeStrength = 40;\n    if (!nodeStrength && nodeStrength !== 0) nodeStrength = 200;\n    if (!nodeSpacing && nodeSpacing !== 0) nodeSpacing = 5;\n    // Force 布局配置项\n    const config = {\n        type: 'gForce',\n        minMovement: 0.01,\n        maxIteration: 2000,\n        preventOverlap: preventOverlap,\n        nodeSize: 100,\n        damping: 0.99,\n        linkDistance: (d)=>{\n            let dist = linkDistance;\n            const sourceNode = $e87b787498170b8e$var$nodeMap[d.source] || $e87b787498170b8e$var$aggregatedNodeMap[d.source];\n            const targetNode = $e87b787498170b8e$var$nodeMap[d.target] || $e87b787498170b8e$var$aggregatedNodeMap[d.target];\n            //若两端都是聚合点\n            if (sourceNode.level && targetNode.level) dist = linkDistance * 3;\n            else if (sourceNode.level || targetNode.level) dist = linkDistance * 1.5;\n            if (!sourceNode.level && !targetNode.level) dist = linkDistance * 0.3;\n            return dist;\n        },\n        edgeStrength: (d)=>{\n            const sourceNode = $e87b787498170b8e$var$nodeMap[d.source] || $e87b787498170b8e$var$aggregatedNodeMap[d.source];\n            const targetNode = $e87b787498170b8e$var$nodeMap[d.target] || $e87b787498170b8e$var$aggregatedNodeMap[d.target];\n            // 聚合节点之间的引力小\n            if (sourceNode.level && targetNode.level) return edgeStrength;\n            // 聚合节点与真实节点之间引力大\n            if (sourceNode.level || targetNode.level) return edgeStrength * 2;\n            return edgeStrength;\n        },\n        nodeStrength: (d)=>{\n            if (d.degree === 1) return 100;\n            if (d.category === \"\\u4EA7\\u4E1A\") return nodeStrength * 3;\n            if (d.level) return nodeStrength * 15;\n            return nodeStrength;\n        },\n        /*   nodeSize: (d) => {\r\n              if (!nodeSize && d.size) return d.size;\r\n             \r\n          }, */ nodeSpacing: (d)=>{\n            if (d.degree === 0) return nodeSpacing * 2;\n            if (d.level) return 400;\n            return nodeSpacing;\n        },\n        // 布局结束后的回调函数\n        onLayoutEnd: ()=>{\n            if (largeGraphMode) graph.getEdges().forEach((edge)=>{\n                if (!edge.orilabel) return;\n                edge.update({\n                    label: $e87b787498170b8e$var$labelFormatter(edge.orilabel, $e87b787498170b8e$var$labelMaxLength)\n                });\n            });\n        },\n        tick: ()=>{\n            graph.refreshPositions();\n        }\n    };\n    if (nodeSize) config['nodeSize'] = nodeSize;\n    if (collideStrength) config['collideStrength'] = collideStrength;\n    if (alpha) config['alpha'] = alpha;\n    if (alphaDecay) config['alphaDecay'] = alphaDecay;\n    if (alphaMin) config['alphaMin'] = alphaMin;\n    return config;\n};\nconst $e87b787498170b8e$var$hideItems = (graph)=>{\n    $e87b787498170b8e$var$hiddenItemIds.forEach((id)=>{\n        graph.hideItem(id);\n    });\n};\nconst $e87b787498170b8e$var$showItems = (graph)=>{\n    graph.getNodes().forEach((node)=>{\n        if (!node.isVisible()) graph.showItem(node);\n    });\n    graph.getEdges().forEach((edge)=>{\n        if (!edge.isVisible()) edge.showItem(edge);\n    });\n    $e87b787498170b8e$var$hiddenItemIds = [];\n};\n// 定义 handleRefreshGraph 函数，更新 Graphin 实例中的图数据\nconst $e87b787498170b8e$var$handleRefreshGraph = (graph, graphData, width, height, largeGraphMode, edgeLabelVisible, isNewGraph)=>{\n    // 如果图数据或 Graphin 实例不存在，则直接返回\n    if (!graphData || !graph) return;\n    // 清除所有节点和边的焦点状态\n    $e87b787498170b8e$var$clearFocusItemState(graph);\n    // 重置过滤\n    graph.getNodes().forEach((node)=>{\n        if (!node.isVisible()) node.show();\n    });\n    graph.getEdges().forEach((edge)=>{\n        if (!edge.isVisible()) edge.show();\n    });\n    let nodes = [], edges = [];\n    // 将更新后的图数据中的节点数据赋值给 nodes 变量\n    nodes = graphData.nodes;\n    // 对节点和边进行处理\n    const processRes = $e87b787498170b8e$var$processNodesEdges(nodes, graphData.edges || [], width, height, largeGraphMode, edgeLabelVisible, isNewGraph);\n    // 将处理后的边数据赋值给 edges 变量\n    edges = processRes.edges;\n    // 更新 Graphin 实例中的图数据\n    graph.changeData({\n        nodes: nodes,\n        edges: edges\n    });\n    // 隐藏所有节点和边\n    $e87b787498170b8e$var$hideItems(graph);\n    // 将所有节点移到前面\n    graph.getNodes().forEach((node)=>{\n        node.toFront();\n    });\n    // 初始化布局\n    $e87b787498170b8e$var$layout.instance.init({\n        nodes: graphData.nodes,\n        edges: edges\n    });\n    // 设置布局参数\n    $e87b787498170b8e$var$layout.instance.minMovement = 0.0001;\n    $e87b787498170b8e$var$layout.instance.getMass = (d)=>{\n        const cachePosition = $e87b787498170b8e$var$cachePositions[d.id];\n        if (cachePosition) return 5;\n        return 1;\n    };\n    // 执行布局算法\n    $e87b787498170b8e$var$layout.instance.execute();\n    // 返回更新后的节点和边数据\n    return {\n        nodes: nodes,\n        edges: edges\n    };\n};\n/**\r\n * 根据聚合数据和原始数据生成节点和边数据\r\n * @param {Object} aggregatedData 聚合数据\r\n * @param {Object} originData 原始数据\r\n * @param {Object} nodeMap 节点映射表\r\n * @param {Object} aggregatedNodeMap 聚合节点映射表\r\n * @param {Array} expandArray 展开数组\r\n * @param {Array} collapseArray 收缩数组\r\n * @returns {Object} 包含节点和边数据的对象\r\n */ const $e87b787498170b8e$var$getMixedGraph = (aggregatedData, originData, nodeMap, aggregatedNodeMap, expandArray, collapseArray)=>{\n    let nodes = [], edges = [];\n    const expandMap = {}, collapseMap = {}; // 存储收缩数组的映射表\n    expandArray.forEach((expandModel)=>{\n        expandMap[expandModel.id] = true;\n    });\n    collapseArray.forEach((collapseModel)=>{\n        collapseMap[collapseModel.id] = true;\n    });\n    // 遍历聚合数据中的每个聚类，根据展开和收缩数组将节点分为两类\n    aggregatedData.clusters.forEach((cluster, i)=>{\n        if (expandMap[cluster.id]) {\n            nodes = nodes.concat(cluster.nodes);\n            aggregatedNodeMap[cluster.id].expanded = true; // 更新聚合节点映射表中该聚类的展开状态为 true\n        } else {\n            nodes.push(aggregatedNodeMap[cluster.id]);\n            aggregatedNodeMap[cluster.id].expanded = false; // 更新聚合节点映射表中该聚类的展开状态为 false\n        }\n    });\n    originData.edges.forEach((edge)=>{\n        const isSourceInExpandArray = expandMap[nodeMap[edge.source].clusterId];\n        const isTargetInExpandArray = expandMap[nodeMap[edge.target].clusterId];\n        if (isSourceInExpandArray && isTargetInExpandArray) edges.push(edge);\n        else if (isSourceInExpandArray) {\n            const targetClusterId = nodeMap[edge.target].clusterId;\n            const vedge = {\n                source: edge.source,\n                target: targetClusterId,\n                id: $e87b787498170b8e$var$uniqueId('edge'),\n                label: ''\n            };\n            edges.push(vedge);\n        } else if (isTargetInExpandArray) {\n            const sourceClusterId = nodeMap[edge.source].clusterId;\n            const vedge = {\n                target: edge.target,\n                source: sourceClusterId,\n                id: $e87b787498170b8e$var$uniqueId('edge'),\n                label: ''\n            };\n            edges.push(vedge);\n        }\n    });\n    aggregatedData.clusterEdges.forEach((edge)=>{\n        if (expandMap[edge.source] || expandMap[edge.target]) return;\n        else edges.push(edge);\n    });\n    return {\n        nodes: nodes,\n        edges: edges\n    };\n};\nconst $e87b787498170b8e$var$examAncestors = (model, expandedArray, length, keepTags)=>{\n    for(let i = 0; i < length; i++){\n        const expandedNode = expandedArray[i];\n        if (!keepTags[i] && model.parentId === expandedNode.id) {\n            keepTags[i] = true; // 需要被保留\n            $e87b787498170b8e$var$examAncestors(expandedNode, expandedArray, length, keepTags);\n            break;\n        }\n    }\n};\nconst $e87b787498170b8e$var$manageExpandCollapseArray = (nodeNumber, model, collapseArray, expandArray)=>{\n    $e87b787498170b8e$var$manipulatePosition = {\n        x: model.x,\n        y: model.y\n    };\n    // 维护 expandArray，若当前画布节点数高于上限，移出 expandedArray 中非 model 祖先的节点)\n    if (nodeNumber > $e87b787498170b8e$var$NODE_LIMIT) {\n        // 若 keepTags[i] 为 true，则 expandedArray 的第 i 个节点需要被保留\n        const keepTags = {};\n        const expandLen = expandArray.length;\n        // 检查 X 的所有祖先并标记 keepTags\n        $e87b787498170b8e$var$examAncestors(model, expandArray, expandLen, keepTags);\n        // 寻找 expandedArray 中第一个 keepTags 不为 true 的点\n        let shiftNodeIdx = -1;\n        for(let i = 0; i < expandLen; i++)if (!keepTags[i]) {\n            shiftNodeIdx = i;\n            break;\n        }\n        // 如果有符合条件的节点，将其从 expandedArray 中移除\n        if (shiftNodeIdx !== -1) {\n            let foundNode = expandArray[shiftNodeIdx];\n            if (foundNode.level === 2) {\n                let foundLevel1 = false;\n                // 找到 expandedArray 中 parentId = foundNode.id 且 level = 1 的第一个节点\n                for(let i = 0; i < expandLen; i++){\n                    const eNode = expandArray[i];\n                    if (eNode.parentId === foundNode.id && eNode.level === 1) {\n                        foundLevel1 = true;\n                        foundNode = eNode;\n                        expandArray.splice(i, 1);\n                        break;\n                    }\n                }\n                // 若未找到，则 foundNode 不变, 直接删去 foundNode\n                if (!foundLevel1) expandArray.splice(shiftNodeIdx, 1);\n            } else // 直接删去 foundNode\n            expandArray.splice(shiftNodeIdx, 1);\n            // const removedNode = expandedArray.splice(shiftNodeIdx, 1); // splice returns an array\n            const idSplits = foundNode.id.split('-');\n            let collapseNodeId;\n            // 去掉最后一个后缀\n            for(let i = 0; i < idSplits.length - 1; i++){\n                const str = idSplits[i];\n                if (collapseNodeId) collapseNodeId = `${collapseNodeId}-${str}`;\n                else collapseNodeId = str;\n            }\n            const collapseNode = {\n                id: collapseNodeId,\n                parentId: foundNode.id,\n                level: foundNode.level - 1\n            };\n            collapseArray.push(collapseNode);\n        }\n    }\n    const currentNode = {\n        id: model.id,\n        level: model.level,\n        parentId: model.parentId\n    };\n    // 加入当前需要展开的节点\n    expandArray.push(currentNode);\n    $e87b787498170b8e$var$graph.get('canvas').setCursor('default');\n    return {\n        expandArray: expandArray,\n        collapseArray: collapseArray\n    };\n};\nconst $e87b787498170b8e$var$cacheNodePositions = (nodes)=>{\n    const positionMap = {};\n    const nodeLength = nodes.length;\n    for(let i = 0; i < nodeLength; i++){\n        const node = nodes[i].getModel();\n        positionMap[node.id] = {\n            x: node.x,\n            y: node.y,\n            level: node.level\n        };\n    }\n    return positionMap;\n};\nconst $e87b787498170b8e$var$stopLayout = ()=>{\n    $e87b787498170b8e$var$layout.instance.stop();\n};\nconst $e87b787498170b8e$var$bindListener = (graph)=>{\n    graph.on('keydown', (evt)=>{\n        const code = evt.key;\n        if (!code) return;\n        if (code.toLowerCase() === 'shift') $e87b787498170b8e$var$shiftKeydown = true;\n        else $e87b787498170b8e$var$shiftKeydown = false;\n    });\n    graph.on('keyup', (evt)=>{\n        const code = evt.key;\n        if (!code) return;\n        if (code.toLowerCase() === 'shift') $e87b787498170b8e$var$shiftKeydown = false;\n    });\n    graph.on('node:mouseenter', (evt)=>{\n        const { item: item } = evt;\n        const model = item.getModel();\n        const currentLabel = model.label;\n        model.oriFontSize = model.labelCfg.style.fontSize;\n        item.update({\n            label: model.orilabel\n        });\n        model.orilabel = currentLabel;\n        graph.setItemState(item, 'hover', true);\n        item.toFront();\n    });\n    graph.on('node:mouseleave', (evt)=>{\n        const { item: item } = evt;\n        const model = item.getModel();\n        const currentLabel = model.label;\n        item.update({\n            label: model.orilabel\n        });\n        model.orilabel = currentLabel;\n        graph.setItemState(item, 'hover', false);\n    });\n    graph.on('edge:mouseenter', (evt)=>{\n        const { item: item } = evt;\n        const model = item.getModel();\n        const currentLabel = model.label;\n        item.update({\n            label: model.orilabel\n        });\n        model.orilabel = currentLabel;\n        item.toFront();\n        item.getSource().toFront();\n        item.getTarget().toFront();\n    });\n    graph.on('edge:mouseleave', (evt)=>{\n        const { item: item } = evt;\n        const model = item.getModel();\n        const currentLabel = model.label;\n        item.update({\n            label: model.orilabel\n        });\n        model.orilabel = currentLabel;\n    });\n    graph.on('node:click', (evt)=>{\n        $e87b787498170b8e$var$stopLayout();\n        if (!$e87b787498170b8e$var$shiftKeydown) $e87b787498170b8e$var$clearFocusItemState(graph);\n        else $e87b787498170b8e$var$clearFocusEdgeState(graph);\n        const { item: item } = evt;\n        // highlight the clicked node, it is down by click-select\n        graph.setItemState(item, 'focus', true);\n        if (!$e87b787498170b8e$var$shiftKeydown) {\n            // 将相关边也高亮\n            const relatedEdges = item.getEdges();\n            relatedEdges.forEach((edge)=>{\n                graph.setItemState(edge, 'focus', true);\n            });\n            // 将相关节点也高亮\n            const relatedNodes = item.getNeighbors().filter((node)=>node.getModel().level === 0);\n            relatedNodes.forEach((node)=>{\n                graph.setItemState(node, 'focus', true);\n            });\n        }\n    });\n    // click edge to show the detail of integrated edge drawer\n    graph.on('edge:click', (evt)=>{\n        $e87b787498170b8e$var$stopLayout();\n        if (!$e87b787498170b8e$var$shiftKeydown) $e87b787498170b8e$var$clearFocusItemState(graph);\n        const { item: item } = evt;\n        // highlight the clicked edge\n        graph.setItemState(item, 'focus', true);\n    });\n    // click canvas to cancel all the focus state\n    graph.on('canvas:click', (evt)=>{\n        $e87b787498170b8e$var$clearFocusItemState(graph);\n        console.log(graph.getGroup(), graph.getGroup().getBBox(), graph.getGroup().getCanvasBBox());\n    });\n};\nconst $e87b787498170b8e$var$subjectMap = {\n    \"\\u4EA7\\u4E1A\": 0,\n    \"\\u6280\\u672F\": 1,\n    \"\\u4F01\\u4E1A\": 2,\n    \"\\u4E13\\u5229\": 3,\n    \"\\u4EA7\\u54C1\": 4,\n    \"\\u805A\\u5408\\u8282\\u70B9\": 5\n};\nconst $e87b787498170b8e$var$industryToClusterId = {\n    \"\\u539F\\u6750\\u6599\": 'cluster1',\n    \"\\u7EC4\\u4EF6\": 'cluster2',\n    \"\\u6574\\u8F66\": 'cluster3',\n    \"\\u5E02\\u573A\\u670D\\u52A1\": 'cluster4',\n    undefined: \"\\u672A\\u5B9A\\u4E49\"\n};\nconst $e87b787498170b8e$var$clusterIdToIndustry = {};\nfor(const industry in $e87b787498170b8e$var$industryToClusterId){\n    const clusterId = $e87b787498170b8e$var$industryToClusterId[industry];\n    $e87b787498170b8e$var$clusterIdToIndustry[clusterId] = industry;\n}\nfunction $e87b787498170b8e$var$clusterByIndustry(data) {\n    const industryMap = new Map();\n    data.nodes.forEach((node)=>{\n        const industry = node.belongsto;\n        if (!industryMap.has(industry)) {\n            const clusterId = `cluster${industryMap.size + 1}`;\n            industryMap.set(industry, {\n                id: clusterId,\n                sumTot: 0,\n                nodes: []\n            });\n        }\n        const cluster = industryMap.get(industry);\n        cluster.nodes.push({\n            ...node,\n            clusterId: cluster.id\n        });\n        cluster.sumTot++;\n    });\n    const clusters = Array.from(industryMap.values());\n    const clusterEdges = [];\n    const edgeMap = new Map();\n    data.edges.forEach((edge)=>{\n        const sourceNode = data.nodes.find((node)=>node.id === edge.source);\n        const targetNode = data.nodes.find((node)=>node.id === edge.target);\n        const sourceClusterId = $e87b787498170b8e$var$industryToClusterId[sourceNode.belongsto];\n        const targetClusterId = $e87b787498170b8e$var$industryToClusterId[targetNode.belongsto];\n        const edgeKey = `${sourceClusterId}-${targetClusterId}`;\n        const reverseEdgeKey = `${targetClusterId}-${sourceClusterId}`;\n        if (edgeMap.has(edgeKey)) {\n            const edge = edgeMap.get(edgeKey);\n            edge.count += 1;\n        } else if (edgeMap.has(reverseEdgeKey)) {\n            const edge = edgeMap.get(reverseEdgeKey);\n            edge.count += 1;\n        } else edgeMap.set(edgeKey, {\n            source: sourceClusterId,\n            target: targetClusterId,\n            count: 1\n        });\n    });\n    clusterEdges.push(...edgeMap.values());\n    return {\n        clusters: clusters,\n        clusterEdges: clusterEdges\n    };\n}\nconst $e87b787498170b8e$var$filenames = [\n    './data/industries.json',\n    './data/enterprises.json',\n    'data/tech_words.json',\n    'data/industries_to_techwords.json',\n    './data/industries_to_industries.json',\n    './data/industries_to_enterprises.json',\n    'data/techwords_to_industries.json'\n];\nconst $e87b787498170b8e$var$getNeighborMixedGraph = (centerNodeModel, neighborType, originData, clusteredData, currentData, nodeMap, aggregatedNodeMap, maxNeighborNumPerNode)=>{\n    // update the manipulate position for center gravity of the new nodes\n    $e87b787498170b8e$var$manipulatePosition = {\n        x: centerNodeModel.x,\n        y: centerNodeModel.y\n    };\n    // the neighborSubGraph does not include the centerNodeModel. the elements are all generated new nodes and edges\n    const neighborSubGraph = $e87b787498170b8e$var$generateNeighbors(centerNodeModel, maxNeighborNumPerNode, neighborType);\n    console.log(neighborSubGraph);\n    // update the origin data\n    originData.nodes = originData.nodes.concat(neighborSubGraph.nodes);\n    originData.edges = originData.edges.concat(neighborSubGraph.edges);\n    // update the origin nodeMap\n    neighborSubGraph.nodes.forEach((node)=>{\n        nodeMap[node.id] = node;\n    });\n    // update the clusteredData\n    const clusterId = centerNodeModel.clusterId;\n    clusteredData.clusters.forEach((cluster)=>{\n        if (cluster.id !== clusterId) return;\n        cluster.nodes = cluster.nodes.concat(neighborSubGraph.nodes);\n        cluster.sumTot += neighborSubGraph.edges.length;\n    });\n    // update the count\n    aggregatedNodeMap[clusterId].count += neighborSubGraph.nodes.length;\n    // Filter out the nodes that already exist in the currentData\n    const newNodes = neighborSubGraph.nodes.filter((node)=>!currentData.nodes.some((n)=>n.id === node.id));\n    const newEdges = neighborSubGraph.edges.filter((edge)=>!currentData.edges.some((n)=>n.id === edge.id));\n    currentData.nodes = currentData.nodes.concat(newNodes);\n    currentData.edges = currentData.edges.concat(newEdges);\n    return currentData;\n};\n/**\r\n * 生成邻居节点\r\n * @param {Object} centerNodeModel 中心节点对象    \r\n * @param {number} maxNeighborNumPerNode 每个节点最多的邻居节点数量\r\n * @param {string} type 生成节点的类型\r\n * @returns {Object} 生成的节点和边对象\r\n */ const $e87b787498170b8e$var$generateNeighbors = (centerNodeModel, maxNeighborNumPerNode = 10, category)=>{\n    // 如果层数小于等于 0，则返回 undefined\n    let generatedData = null;\n    if (generatedData) return generatedData;\n    // 初始化节点数组和边数组\n    let nodes = [], edges = [];\n    // 获取中心节点的簇 ID 和 ID\n    const clusterId = centerNodeModel.clusterId;\n    const centerId = centerNodeModel.id;\n    // 随机生成邻居节点的数量\n    const neighborNum = Math.ceil(Math.random() * maxNeighborNumPerNode);\n    // 循环生成技术邻居节点\n    for(let i = 0; i < neighborNum; i++){\n        // 定义一个新的邻居节点，并设置属性\n        const neighborNode = {\n            id: category === \"\\u4E13\\u5229\" ? generateRandomPatentName() : products[Math.floor(Math.random() * products.length)],\n            clusterId: clusterId,\n            level: 0,\n            category: category,\n            colorSet: category === \"\\u4E13\\u5229\" ? $e87b787498170b8e$var$colorSets[3] : $e87b787498170b8e$var$colorSets[4]\n        };\n        // 将新的邻居节点添加到节点数组中\n        nodes.push(neighborNode);\n        nodes.forEach((node)=>{\n            node.orilabel = node.id;\n            node.label = $e87b787498170b8e$var$labelFormatter(node.orilabel, 5);\n        });\n        // 随机生成边的方向\n        // 根据方向设置边的起点和终点\n        const source = centerId;\n        const target = neighborNode.id;\n        // 定义一条新的边，并设置属性\n        const neighborEdge = {\n            id: `${source}-${target}`,\n            source: source,\n            target: target,\n            label: centerNodeModel.category === \"\\u6280\\u672F\" ? \"\\u76F8\\u5173\\u4E13\\u5229\" : \"\\u4E3B\\u8425\\u4EA7\\u54C1\"\n        };\n        // 将新的边添加到边数组中\n        edges.push(neighborEdge);\n    }\n    // 返回生成的节点数组和边数组\n    return {\n        nodes: nodes,\n        edges: edges\n    };\n};\nPromise.all($e87b787498170b8e$var$filenames.map((filename)=>fetch(filename).then((response)=>response.json()))).then((dataArr)=>{\n    const data = dataArr.reduce((acc, data)=>{\n        if (data.nodes) acc.nodes.push(...data.nodes);\n        if (data.edges) acc.edges.push(...data.edges);\n        return acc;\n    }, {\n        nodes: [],\n        edges: []\n    });\n    const stats = {\n        industry: 0,\n        technology: 0,\n        enterprise: 0\n    };\n    data.nodes.forEach((node)=>{\n        switch(node.category){\n            case \"\\u4EA7\\u4E1A\":\n                stats.industry += 1;\n                break;\n            case \"\\u6280\\u672F\":\n                stats.technology += 1;\n                break;\n            case \"\\u4F01\\u4E1A\":\n                stats.enterprise += 1;\n                break;\n            default:\n                break;\n        }\n    });\n    const typeConfigs = {\n        'indus': {\n            type: 'circle',\n            size: 20,\n            style: {\n                fill: '#0f63a9',\n                stroke: '#0f63a9',\n                lineWidth: 2,\n                opacity: 0.5\n            }\n        },\n        'technology': {\n            type: 'circle',\n            size: 20,\n            style: {\n                fill: '#eb4d4b',\n                stroke: '#eb4d4b',\n                lineWidth: 2,\n                opacity: 0.5,\n                stoke: '#dff9fb'\n            }\n        },\n        'enterprise': {\n            type: 'circle',\n            size: 20,\n            style: {\n                fill: 'rgba(251, 197, 49,1.0)',\n                stroke: 'rgba(251, 197, 49,1.0)',\n                lineWidth: 2,\n                opacity: 0.5\n            }\n        },\n        'patent': {\n            type: 'circle',\n            size: 20,\n            style: {\n                fill: '#91cc75',\n                stroke: '#91cc75',\n                lineWidth: 2,\n                opacity: 0.5\n            }\n        },\n        'product': {\n            type: 'circle',\n            size: 20,\n            style: {\n                fill: ' rgba(156, 136, 255,1.0)',\n                stroke: 'rgba(156, 136, 255,1.0)',\n                lineWidth: 2,\n                opacity: 0.5\n            }\n        }\n    };\n    const legendData = {\n        nodes: [\n            {\n                id: 'indus',\n                label: `\\u{4EA7}\\u{4E1A}\\u{FF1A}${stats.industry + 48}`,\n                ...typeConfigs['indus']\n            },\n            {\n                id: 'technology',\n                label: `\\u{6280}\\u{672F}\\u{FF1A}${stats.technology + 300}`,\n                ...typeConfigs['technology']\n            },\n            {\n                id: 'enterprise',\n                label: `\\u{4F01}\\u{4E1A}\\u{FF1A}${stats.enterprise + 300}`,\n                ...typeConfigs['enterprise']\n            },\n            {\n                id: 'patent',\n                label: \"\\u4E13\\u5229\\uFF1A589\",\n                ...typeConfigs['patent']\n            },\n            {\n                id: 'product',\n                label: \"\\u4EA7\\u54C1\\uFF1A487\",\n                ...typeConfigs['product']\n            }\n        ]\n    };\n    const legend = new G6.Legend({\n        data: legendData,\n        align: 'center',\n        layout: 'vertical',\n        position: 'right-top',\n        vertiSep: 5,\n        horiSep: 5,\n        margin: 5,\n        offsetX: 2,\n        offsetY: 1,\n        padding: 16,\n        containerStyle: {\n            fill: 'rgba(220, 221, 225,0.5)',\n            opacity: 0.8,\n            lineWidth: 1,\n            radius: 30\n        },\n        title: \"\\u56FE\\u4F8B\",\n        titleConfig: {\n            position: 'center',\n            offsetX: 5,\n            offsetY: 10\n        },\n        filter: {\n            enable: true,\n            multiple: true,\n            trigger: 'click',\n            graphActiveState: 'focus',\n            filterFunctions: {\n                'technology': (d)=>{\n                    if (d.category === \"\\u6280\\u672F\") return true;\n                    return false;\n                },\n                'enterprise': (d)=>{\n                    if (d.category === \"\\u4F01\\u4E1A\") return true;\n                    return false;\n                },\n                'patent': (d)=>{\n                    if (d.category === \"\\u4E13\\u5229\") return true;\n                    return false;\n                },\n                'indus': (d)=>{\n                    if (d.category === \"\\u4EA7\\u4E1A\") return true;\n                    return false;\n                }\n            }\n        }\n    });\n    // console.log(stats)\n    const container = document.getElementById('container');\n    container.style.backgroundColor = '#2b2f33';\n    $e87b787498170b8e$var$CANVAS_WIDTH = container.scrollWidth - 20;\n    $e87b787498170b8e$var$CANVAS_HEIGHT = (container.scrollHeight || 600) - 10;\n    $e87b787498170b8e$var$nodeMap = {};\n    // 使用louvain算法对数据进行聚类，将结果存储到clusteredData中\n    /* const clusteredData = louvain(data, false, 'count'); */ const clusteredData = $e87b787498170b8e$var$clusterByIndustry(data);\n    // 初始化一个聚合后的数据对象aggregatedData\n    const aggregatedData = {\n        nodes: [],\n        edges: []\n    };\n    // 遍历每个聚类，并将其中的节点加入到aggregatedData中\n    clusteredData.clusters.forEach((cluster, i)=>{\n        // 遍历聚类中的每个节点\n        cluster.nodes.forEach((node)=>{\n            // 对每个节点设置属性\n            node.level = 0;\n            node.orilabel = node.id;\n            node.label = $e87b787498170b8e$var$formatText(node.orilabel, $e87b787498170b8e$var$labelMaxLength, '...');\n            node.colorSet = $e87b787498170b8e$var$colorSets[$e87b787498170b8e$var$subjectMap[node.category]];\n            // 将节点对象存储到nodeMap中，key为节点id\n            $e87b787498170b8e$var$nodeMap[node.id] = node;\n            node.isExpanded = false;\n            node.isNeighborShowed = false;\n        });\n        // 生成聚类产业节点inode\n        const inode = {\n            id: cluster.id,\n            category: \"\\u805A\\u5408\\u8282\\u70B9\",\n            count: cluster.nodes.length,\n            level: 1,\n            orilabel: $e87b787498170b8e$var$clusterIdToIndustry[cluster.id],\n            label: $e87b787498170b8e$var$clusterIdToIndustry[cluster.id],\n            colorSet: $e87b787498170b8e$var$colorSets[$e87b787498170b8e$var$subjectMap[\"\\u805A\\u5408\\u8282\\u70B9\"]],\n            idx: i\n        };\n        // 将聚类节点对象存储到aggregatedNodeMap中，key为聚类id\n        $e87b787498170b8e$var$aggregatedNodeMap[cluster.id] = inode;\n        // 将聚类节点对象存储到aggregatedData的节点数组中\n        aggregatedData.nodes.push(inode);\n    });\n    // 遍历聚类边，并将其加入到aggregatedData中\n    clusteredData.clusterEdges.forEach((clusterEdge)=>{\n        // 生成聚类边对象cedge\n        const cedge = {\n            ...clusterEdge,\n            size: Math.log(clusterEdge.count),\n            label: '',\n            id: $e87b787498170b8e$var$uniqueId('edge')\n        };\n        // 判断是否为环\n        if (cedge.source === cedge.target) {\n            cedge.type = 'loop';\n            cedge.loopCfg = {\n                dist: 20\n            };\n        } else // 如果不是环，则设置为线性\n        cedge.type = 'line';\n        // 将聚类边对象存储到aggregatedData的边数组中\n        aggregatedData.edges.push(cedge);\n    });\n    // 对原始数据的边进行操作，设置label和id属性\n    data.edges.forEach((edge)=>{\n        edge.id = `${edge.source}-${edge.target}`;\n    });\n    // 将聚合后的数据对象赋值给currentUnproccessedData\n    $e87b787498170b8e$var$currentUnproccessedData = aggregatedData;\n    // 处理节点和边的位置，以适应当前画布大小\n    const { edges: processedEdges } = $e87b787498170b8e$var$processNodesEdges($e87b787498170b8e$var$currentUnproccessedData.nodes, $e87b787498170b8e$var$currentUnproccessedData.edges, $e87b787498170b8e$var$CANVAS_WIDTH, $e87b787498170b8e$var$CANVAS_HEIGHT, $e87b787498170b8e$var$largeGraphMode, true, true);\n    const contextMenu = new G6.Menu({\n        shouldBegin (evt) {\n            if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) return true;\n            if (evt.item) return true;\n            return false;\n        },\n        getContent (evt) {\n            const { item: item } = evt;\n            if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) return `<ul>\n          <li id='show'>\\u{663E}\\u{793A}\\u{6240}\\u{6709}\\u{9690}\\u{85CF}\\u{8282}\\u{70B9}</li>\n          <li id='collapseAll'>\\u{6298}\\u{53E0}\\u{6240}\\u{6709}\\u{8282}\\u{70B9}</li>\n        </ul>`;\n            else if (!item) return;\n            const itemType = item.getType();\n            const model = item.getModel();\n            // console.log(model);\n            if (itemType && model) {\n                if (itemType === 'node') {\n                    let html = `<ul>\n                        \n                            <li id='hide'>\\u{9690}\\u{85CF}\\u{8BE5}\\u{8282}\\u{70B9}</li>\n                          </ul>`;\n                    if (model.level !== 0) {\n                        html += `<ul>\n                            <li id='expand'>\\u{5C55}\\u{5F00}\\u{76F8}\\u{5173}\\u{8282}\\u{70B9}</li>\n                           \n                          </ul>`;\n                        return html;\n                    } else {\n                        let expandCollapseMenu;\n                        html += `<ul>\n                            <li id='collapse'>\\u{6536}\\u{7F29}\\u{8BE5}\\u{8282}\\u{70B9}</li>\n                               \n                              </ul>`;\n                        if (model.category === \"\\u6280\\u672F\") {\n                            if (!model.isExpanded) html += `<ul>\n                                    <li id='neighbor-\\u{5C55}\\u{5F00}'>\\u{5C55}\\u{5F00}\\u{76F8}\\u{5173}\\u{4E13}\\u{5229}</li>\n                                   </ul>`;\n                            else html += `<ul>\n                                  <li id='neighbor-\\u{6536}\\u{7F29}'>\\u{6536}\\u{7F29}\\u{76F8}\\u{5173}\\u{4E13}\\u{5229}</li>\n                                 </ul>`;\n                            return html;\n                        }\n                        if (model.category === \"\\u4F01\\u4E1A\") {\n                            if (!model.isExpanded) html += `<ul>\n                                    <li id='neighbor-\\u{5C55}\\u{5F00}'>\\u{5C55}\\u{5F00}\\u{76F8}\\u{5173}\\u{4EA7}\\u{54C1}</li>\n                                   </ul>`;\n                            else html += `<ul>\n                                <li id='neighbor-\\u{6536}\\u{7F29}'>\\u{6536}\\u{7F29}\\u{76F8}\\u{5173}\\u{4EA7}\\u{54C1}</li>\n                               </ul>`;\n                            return html;\n                        } else return `<ul>\n                            <li id='collapse'>\\u{6536}\\u{7F29}\\u{8282}\\u{70B9}</li>\n                            <li id='hide'>\\u{9690}\\u{85CF}\\u{8BE5}\\u{8282}\\u{70B9}</li>\n                          </ul>`;\n                    }\n                } else return `<ul>\n            <li id='hide'>\\u{9690}\\u{85CF}\\u{8BE5}\\u{8FB9}</li>\n          </ul>`;\n            }\n        },\n        handleMenuClick: (target, item)=>{\n            const model = item && item.getModel();\n            const liIdStrs = target.id.split('-');\n            let mixedGraphData;\n            switch(liIdStrs[0]){\n                case 'return':\n                    $e87b787498170b8e$var$graph.getNodes().forEach((item)=>{\n                        if (item.getModel().id !== model.id) {\n                            if (item.getModel().category === \"\\u6280\\u672F\") $e87b787498170b8e$var$graph.showItem(item);\n                            else {\n                                $e87b787498170b8e$var$graph.hideItem(item);\n                                $e87b787498170b8e$var$hiddenItemIds.push(model.id);\n                            }\n                        }\n                    });\n                case 'hide':\n                    $e87b787498170b8e$var$graph.hideItem(item);\n                    $e87b787498170b8e$var$hiddenItemIds.push(model.id);\n                    break;\n                case 'expand':\n                    const newArray = $e87b787498170b8e$var$manageExpandCollapseArray($e87b787498170b8e$var$graph.getNodes().length, model, $e87b787498170b8e$var$collapseArray, $e87b787498170b8e$var$expandArray);\n                    $e87b787498170b8e$var$expandArray = newArray.expandArray;\n                    $e87b787498170b8e$var$collapseArray = newArray.collapseArray;\n                    mixedGraphData = $e87b787498170b8e$var$getMixedGraph(clusteredData, data, $e87b787498170b8e$var$nodeMap, $e87b787498170b8e$var$aggregatedNodeMap, $e87b787498170b8e$var$expandArray, $e87b787498170b8e$var$collapseArray);\n                    break;\n                case 'collapse':\n                    const aggregatedNode = $e87b787498170b8e$var$aggregatedNodeMap[model.clusterId];\n                    $e87b787498170b8e$var$manipulatePosition = {\n                        x: aggregatedNode.x,\n                        y: aggregatedNode.y\n                    };\n                    $e87b787498170b8e$var$collapseArray.push(aggregatedNode);\n                    $e87b787498170b8e$var$showItems($e87b787498170b8e$var$graph);\n                    for(let i = 0; i < $e87b787498170b8e$var$expandArray.length; i++)if ($e87b787498170b8e$var$expandArray[i].id === model.clusterId) {\n                        $e87b787498170b8e$var$expandArray.splice(i, 1);\n                        break;\n                    }\n                    mixedGraphData = $e87b787498170b8e$var$getMixedGraph(clusteredData, data, $e87b787498170b8e$var$nodeMap, $e87b787498170b8e$var$aggregatedNodeMap, $e87b787498170b8e$var$expandArray, $e87b787498170b8e$var$collapseArray);\n                    break;\n                case 'collapseAll':\n                    $e87b787498170b8e$var$expandArray = [];\n                    $e87b787498170b8e$var$collapseArray = [];\n                    mixedGraphData = $e87b787498170b8e$var$getMixedGraph(clusteredData, data, $e87b787498170b8e$var$nodeMap, $e87b787498170b8e$var$aggregatedNodeMap, $e87b787498170b8e$var$expandArray, $e87b787498170b8e$var$collapseArray);\n                    $e87b787498170b8e$var$showItems($e87b787498170b8e$var$graph);\n                    break;\n                case 'neighbor':\n                    const neighborNodes = item.getNeighbors();\n                    const expandNeighborType = model.category === \"\\u6280\\u672F\" ? \"\\u4E13\\u5229\" : \"\\u4EA7\\u54C1\";\n                    if (model.isNeighborShowed === false) mixedGraphData = $e87b787498170b8e$var$getNeighborMixedGraph(model, expandNeighborType, data, clusteredData, $e87b787498170b8e$var$currentUnproccessedData, $e87b787498170b8e$var$nodeMap, $e87b787498170b8e$var$aggregatedNodeMap, 10);\n                    model.isNeighborShowed = true;\n                    if (liIdStrs[1] === \"\\u5C55\\u5F00\") neighborNodes.forEach((item)=>{\n                        if (item.getModel().category !== \"\\u4EA7\\u4E1A\") $e87b787498170b8e$var$graph.showItem(item);\n                    });\n                    else if (liIdStrs[1] === \"\\u6536\\u7F29\") {\n                        console.log(neighborNodes);\n                        neighborNodes.forEach((item)=>{\n                            if (item.getModel().category !== \"\\u4EA7\\u4E1A\") {\n                                $e87b787498170b8e$var$graph.hideItem(item);\n                                $e87b787498170b8e$var$hiddenItemIds.push(item.getModel().id);\n                            }\n                        });\n                    }\n                    $e87b787498170b8e$var$graph.getNodes().forEach((item)=>{\n                        if (item.getModel().level) {\n                            if (item.getModel().id !== model.id) {\n                                $e87b787498170b8e$var$graph.hideItem(item);\n                                $e87b787498170b8e$var$hiddenItemIds.push(item.getModel().id);\n                            }\n                        }\n                    });\n                    model.isExpanded = !model.isExpanded;\n                    break;\n                case 'show':\n                    $e87b787498170b8e$var$showItems($e87b787498170b8e$var$graph);\n                    break;\n                default:\n                    break;\n            }\n            if (mixedGraphData) {\n                $e87b787498170b8e$var$cachePositions = $e87b787498170b8e$var$cacheNodePositions($e87b787498170b8e$var$graph.getNodes());\n                $e87b787498170b8e$var$currentUnproccessedData = mixedGraphData;\n                $e87b787498170b8e$var$handleRefreshGraph($e87b787498170b8e$var$graph, $e87b787498170b8e$var$currentUnproccessedData, $e87b787498170b8e$var$CANVAS_WIDTH, $e87b787498170b8e$var$CANVAS_HEIGHT, $e87b787498170b8e$var$largeGraphMode, true, false);\n            }\n        },\n        // offsetX and offsetY include the padding of the parent container\n        // 需要加上父级容器的 padding-left 16 与自身偏移量 10\n        offsetX: 26,\n        // 需要加上父级容器的 padding-top 24 、画布兄弟元素高度、与自身偏移量 10\n        offsetY: 0,\n        // the types of items that allow the menu show up\n        // 在哪些类型的元素上响应\n        itemTypes: [\n            'node',\n            'edge',\n            'canvas'\n        ]\n    });\n    $e87b787498170b8e$var$graph = new G6.Graph({\n        container: 'container',\n        width: $e87b787498170b8e$var$CANVAS_WIDTH,\n        height: $e87b787498170b8e$var$CANVAS_HEIGHT,\n        linkCenter: true,\n        minZoom: 0.1,\n        modes: {\n            default: [\n                {\n                    type: 'drag-canvas',\n                    enableOptimize: true\n                },\n                {\n                    type: 'zoom-canvas',\n                    enableOptimize: true,\n                    optimizeZoom: 0.01\n                },\n                {\n                    type: 'scroll-canvas',\n                    direction: 'both',\n                    enableOptimize: true,\n                    zoomKey: 'ctrl',\n                    scalableRange: -0.3\n                },\n                {\n                    type: 'lasso-select',\n                    selectedState: 'focus',\n                    trigger: 'shift'\n                },\n                'drag-node',\n                'shortcuts-call'\n            ]\n        },\n        plugins: [\n            contextMenu,\n            (0, $f030692716f7b8a2$export$85fc379452d91af0),\n            (0, $f030692716f7b8a2$export$4e6f96734dfe12f4),\n            legend\n        ]\n    });\n    const layoutConfig = $e87b787498170b8e$var$getForceLayoutConfig($e87b787498170b8e$var$graph, $e87b787498170b8e$var$largeGraphMode);\n    layoutConfig.center = [\n        $e87b787498170b8e$var$CANVAS_WIDTH / 2,\n        $e87b787498170b8e$var$CANVAS_HEIGHT / 2\n    ];\n    $e87b787498170b8e$var$layout.instance = new G6.Layout['gForce'](layoutConfig);\n    $e87b787498170b8e$var$layout.instance.init({\n        nodes: $e87b787498170b8e$var$currentUnproccessedData.nodes,\n        edges: processedEdges\n    });\n    $e87b787498170b8e$var$layout.instance.execute();\n    $e87b787498170b8e$var$bindListener($e87b787498170b8e$var$graph);\n    $e87b787498170b8e$var$graph.data({\n        nodes: aggregatedData.nodes,\n        edges: processedEdges\n    });\n    $e87b787498170b8e$var$graph.render();\n});\n// 遍历所有节点\nif (typeof window !== 'undefined') window.onresize = ()=>{\n    if (!$e87b787498170b8e$var$graph || $e87b787498170b8e$var$graph.get('destroyed')) return;\n    const container = document.getElementById('container');\n    if (!container) return;\n    $e87b787498170b8e$var$graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\n};\n\n\n//# sourceMappingURL=index.c46b125a.js.map\n","/* import G6 from '@antv/g6'; */\r\nimport { grid, tooltip } from \"./plugin.js\";\r\n// 获取搜索框和按钮元素\r\nconst searchInput = document.getElementById('search-input');\r\nconst searchButton = document.getElementById('search-button');\r\nconst candidateList = document.createElement('ul');\r\ncandidateList.className = 'candidate-list';\r\nconst searchWrapper = document.querySelector('.search-wrapper');\r\nsearchWrapper.appendChild(candidateList);\r\n\r\n\r\n\r\n\r\nsearchButton.addEventListener('click', () => {\r\n    const keyword = searchInput.value; // 获取搜索关键字\r\n    const nodes = graph.findAll('node', node => node.getModel().orilabel.includes(keyword) || node.getModel().category === (keyword));\r\n\r\n\r\n    if (nodes && nodes.length > 0) {\r\n        const count = nodes.length;\r\n        console.warn(`一共找到 ${count} 个节点.`);\r\n        nodes.forEach(node => {\r\n            graph.setItemState(node, 'focus', true); // 设置节点选中状态\r\n            graph.focusItem(node); // 将节点居中展开\r\n\r\n        });\r\n\r\n\r\n    } else\r\n        alert('没有找到符合条件的节点');\r\n\r\n});\r\n\r\n\r\ncandidateList.addEventListener('click', (e) => {\r\n    searchInput.value = e.target.innerHTML;\r\n    console.log(searchInput.value);\r\n});\r\n\r\n\r\n\r\n\r\n// 绑定搜索按钮点击事件\r\nsearchInput.addEventListener('input', () => {\r\n    const keyword = searchInput.value; // 获取搜索关键字\r\n    const nodes = graph.findAll('node', node => node.getModel().orilabel.includes(keyword) || node.getModel().category === keyword);\r\n\r\n    // 清空候选列表\r\n    candidateList.innerHTML = '';\r\n\r\n    if (nodes && nodes.length > 0) {\r\n\r\n\r\n        nodes.forEach(node => {\r\n\r\n\r\n            const candidate = document.createElement('li');\r\n            candidate.className = 'candidate-item';\r\n            candidate.innerHTML = node.getModel().orilabel;\r\n\r\n            candidateList.appendChild(candidate);\r\n        });\r\n\r\n        // 显示候选列表\r\n        candidateList.style.display = 'block';\r\n    } else {\r\n\r\n\r\n        // 隐藏候选列表\r\n        candidateList.style.display = 'none';\r\n    }\r\n});\r\n\r\nsearchInput.addEventListener('keydown', (event) => {\r\n    if (event.key === 'Enter') {\r\n        const keyword = searchInput.value; // 获取搜索关键字\r\n        const nodes = graph.findAll('node', node => node.getModel().orilabel.includes(keyword) || node.getModel().category === (keyword));\r\n\r\n\r\n        if (nodes && nodes.length > 0) {\r\n            const count = nodes.length;\r\n            alert(`一共找到 ${count} 个节点.`);\r\n            nodes.forEach(node => {\r\n                graph.setItemState(node, 'focus', true); // 设置节点选中状态\r\n                graph.focusItem(node); // 将节点居中展开\r\n\r\n            });\r\n\r\n\r\n        } else\r\n            alert('没有找到符合条件的节点');\r\n    }\r\n});\r\n\r\n\r\n\r\nconst { uniqueId } = G6.Util;\r\n\r\nconst NODESIZEMAPPING = 'degree';\r\nconst SMALLGRAPHLABELMAXLENGTH = 5;\r\nlet labelMaxLength = SMALLGRAPHLABELMAXLENGTH;\r\n/* const DEFAULTNODESIZE = 20;\r\nconst DEFAULTAGGREGATEDNODESIZE = 53; */\r\nconst NODE_LIMIT = 2000; // TODO: find a proper number for maximum node number on the canvas\r\n\r\nlet graph = null;\r\nlet currentUnproccessedData = { nodes: [], edges: [] };\r\nlet nodeMap = {};\r\nlet aggregatedNodeMap = {};\r\nlet hiddenItemIds = []; // \b隐藏的元素 id 数组\r\nlet largeGraphMode = true;\r\nlet cachePositions = {};\r\nlet manipulatePosition = undefined;\r\nlet descreteNodeCenter;\r\nlet layout = {\r\n    type: '',\r\n    instance: null,\r\n    destroyed: true,\r\n};\r\nlet expandArray = [];\r\nlet collapseArray = [];\r\nlet shiftKeydown = false;\r\n\r\nlet CANVAS_WIDTH = 1000,\r\n    CANVAS_HEIGHT = 600;\r\n\r\nconst duration = 4000;\r\nconst animateOpacity = 0.6;\r\nconst animateBackOpacity = 0.1;\r\nconst virtualEdgeOpacity = 0.1;\r\nconst realEdgeOpacity = 0.2;\r\n\r\nconst darkBackColor = 'rgb(43, 47, 51)';\r\nconst disableColor = '#777';\r\nconst theme = 'dark';\r\nconst subjectColors = [\r\n    '#0f63a9',\r\n    '#eb4d4b',\r\n    'rgba(251, 197, 49,1.0)',\r\n    '#91cc75',\r\n    'rgba(156, 136, 255,1.0)',\r\n    'rgba(127, 143, 166,1.0)'\r\n];\r\n\r\nconst colorSets = G6.Util.getColorSetsBySubjectColors(\r\n    subjectColors,\r\n    darkBackColor,\r\n    theme,\r\n    disableColor,\r\n);\r\n\r\nconst global = {\r\n    node: {\r\n        style: {\r\n            fill: '#2B384E',\r\n        },\r\n        labelCfg: {\r\n            style: {\r\n                fill: '#acaeaf',\r\n                stroke: '#191b1c',\r\n            },\r\n        },\r\n        stateStyles: {\r\n            focus: {\r\n                fill: '#2B384E',\r\n            },\r\n            selected: {\r\n                lineWidth: 10,\r\n                strokeOpacity: 0.5\r\n            },\r\n            activeByLegend: {\r\n                lineWidth: 10,\r\n                strokeOpacity: 0.5\r\n            },\r\n            inactiveByLegend: {\r\n                opacity: 0.5\r\n            }\r\n        },\r\n    },\r\n    edge: {\r\n        style: {\r\n            stroke: '#acaeaf',\r\n            realEdgeStroke: '#acaeaf', //'#f00',\r\n            realEdgeOpacity,\r\n            strokeOpacity: realEdgeOpacity,\r\n        },\r\n        labelCfg: {\r\n            style: {\r\n                fill: '#acaeaf',\r\n                realEdgeStroke: '#acaeaf', //'#f00',\r\n                realEdgeOpacity: 0.5,\r\n                stroke: '#191b1c',\r\n            },\r\n        },\r\n        stateStyles: {\r\n            focus: {\r\n                stroke: '#fff', // '#3C9AE8',\r\n            },\r\n        },\r\n    },\r\n};\r\n\r\n\r\nG6.registerNode(\r\n    '聚合节点', {\r\n        draw(cfg, group) {\r\n\r\n            let width = cfg.count * 2,\r\n                height = cfg.count * 2;\r\n            const style = cfg.style || {};\r\n            const colorSet = cfg.colorSet || colorSets[0];\r\n\r\n            // halo for hover\r\n            group.addShape('rect', {\r\n                attrs: {\r\n                    x: -width * 0.6,\r\n                    y: -height * 0.6,\r\n                    width: width * 1.2,\r\n                    height: height * 1.2,\r\n                    fill: colorSet.mainFill,\r\n                    opacity: 0.8,\r\n                    lineWidth: 0.5,\r\n                    radius: (height / 2 || 13) * 1.2,\r\n                },\r\n                // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\r\n                name: 'halo-shape',\r\n                visible: false,\r\n            });\r\n\r\n            // focus stroke for hover\r\n            group.addShape('rect', {\r\n                attrs: {\r\n                    x: -width * 0.6,\r\n                    y: -height * 0.6,\r\n                    width: width * 1.2,\r\n                    height: height * 1.2,\r\n                    fill: colorSet.mainFill, // '#3B4043',\r\n                    stroke: 'rgba(245, 246, 250,1.0)',\r\n                    lineWidth: 3,\r\n                    lineOpacty: 0.5,\r\n                    radius: (height / 2 || 13) * 1.2,\r\n                },\r\n                name: 'stroke-shape',\r\n                visible: false,\r\n            });\r\n\r\n            const keyShape = group.addShape('rect', {\r\n                attrs: {\r\n                    ...style,\r\n                    x: -width / 2,\r\n                    y: -height / 2,\r\n                    width,\r\n                    height,\r\n                    fill: colorSet.mainFill, // || '#3B4043',\r\n                    opacity: 0.2,\r\n                    stroke: colorSet.mainStroke,\r\n                    lineWidth: 4,\r\n                    cursor: 'pointer',\r\n                    radius: height / 2 || 13,\r\n                    lineDash: [12, 12],\r\n                },\r\n                // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\r\n                name: 'aggregated-node-keyShape',\r\n            });\r\n\r\n            let labelStyle = {};\r\n            if (cfg.labelCfg) {\r\n                labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);\r\n            }\r\n            group.addShape('text', {\r\n                attrs: {\r\n                    text: cfg.label,\r\n                    x: 0,\r\n                    y: -10,\r\n                    textAlign: 'center',\r\n                    textBaseline: 'middle',\r\n                    cursor: 'pointer',\r\n                    fontSize: 14,\r\n                    fill: 'rgba(245, 246, 250,0.8)',\r\n                    fontWeight: 600,\r\n                },\r\n                name: 'label-shape',\r\n                className: 'label-shape',\r\n            });\r\n\r\n            group.addShape('text', {\r\n                attrs: {\r\n                    text: `节点总数：${cfg.count + 431}`,\r\n                    x: 0,\r\n                    y: 10,\r\n                    textAlign: 'center',\r\n                    textBaseline: 'middle',\r\n                    cursor: 'pointer',\r\n                    fontSize: 12,\r\n                    fill: 'rgba(220, 221, 225,0.8)',\r\n                    opacity: 0.85,\r\n                    fontWeight: 400,\r\n                },\r\n                name: 'count-shape',\r\n                className: 'count-shape',\r\n                draggable: true,\r\n            });\r\n\r\n\r\n            // tag for new node\r\n            if (cfg.new) {\r\n                group.addShape('circle', {\r\n                    attrs: {\r\n                        x: width / 2 - 3,\r\n                        y: -height / 2 + 3,\r\n                        r: 4,\r\n                        fill: '#6DD400',\r\n                        lineWidth: 0.5,\r\n                        stroke: '#FFFFFF',\r\n                    },\r\n                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\r\n                    name: 'typeNode-tag-circle',\r\n                });\r\n            }\r\n            return keyShape;\r\n        },\r\n        setState: (name, value, item) => {\r\n            const group = item.get('group');\r\n            if (name === 'layoutEnd' && value) {\r\n                const labelShape = group.find((e) => e.get('name') === 'text-shape');\r\n                if (labelShape) labelShape.set('visible', true);\r\n            } else if (name === 'hover') {\r\n                if (item.hasState('focus')) {\r\n                    return;\r\n                }\r\n                const halo = group.find((e) => e.get('name') === 'halo-shape');\r\n                const keyShape = item.getKeyShape();\r\n                const colorSet = item.getModel().colorSet || colorSets[0];\r\n                if (value) {\r\n                    halo && halo.show();\r\n                    keyShape.attr('fill', colorSet.activeFill);\r\n                } else {\r\n                    halo && halo.hide();\r\n                    keyShape.attr('fill', colorSet.mainFill);\r\n                }\r\n            } else if (name === 'focus') {\r\n                const stroke = group.find((e) => e.get('name') === 'stroke-shape');\r\n                const keyShape = item.getKeyShape();\r\n                const colorSet = item.getModel().colorSet || colorSets[0];\r\n                if (value) {\r\n                    stroke && stroke.show();\r\n                    keyShape.attr('fill', colorSet.selectedFill);\r\n                } else {\r\n                    stroke && stroke.hide();\r\n                    keyShape.attr('fill', colorSet.mainFill);\r\n                }\r\n            }\r\n        },\r\n        update: undefined,\r\n    },\r\n    '聚合节点',\r\n);\r\n\r\n\r\nG6.registerNode(\r\n    '普通节点', {\r\n        draw(cfg, group) {\r\n\r\n            const degreeSum = cfg.degree;\r\n\r\n            var r = (degreeSum * 1.5) + 5;\r\n            /*   if (isNumber(cfg.size)) {\r\n                  r = cfg.size / 2;\r\n              } else if (isArray(cfg.size)) {\r\n                  r = cfg.size[0] / 2;\r\n              } */\r\n            const style = cfg.style || {};\r\n            const colorSet = cfg.colorSet || colorSets[0];\r\n\r\n\r\n\r\n            // halo for hover\r\n            group.addShape('circle', {\r\n                attrs: {\r\n                    x: 0,\r\n                    y: 0,\r\n                    r: r + 5,\r\n                    fill: style.fill || colorSet.mainFill || '#2B384E',\r\n                    opacity: 0.7,\r\n                    lineWidth: 0,\r\n                },\r\n                // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\r\n                name: 'halo-shape',\r\n                visible: false,\r\n            });\r\n\r\n            // focus stroke for hover\r\n            group.addShape('circle', {\r\n                attrs: {\r\n                    x: 0,\r\n                    y: 0,\r\n                    r: r + 5,\r\n\r\n                    fill: style.fill || colorSet.mainFill || '#2B384E',\r\n                    stroke: 'rgba(245, 246, 250,1.0)',\r\n                    strokeOpacity: 0.85,\r\n                    lineWidth: 2,\r\n                },\r\n                // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\r\n                name: 'stroke-shape',\r\n                visible: false,\r\n            });\r\n\r\n            const keyShape = group.addShape('circle', {\r\n                attrs: {\r\n                    ...style,\r\n                    x: 0,\r\n                    y: 0,\r\n                    r,\r\n                    fill: colorSet.mainFill,\r\n\r\n                    stroke: colorSet.mainStroke,\r\n                    lineWidth: 2,\r\n                    cursor: 'pointer',\r\n                },\r\n                // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\r\n                name: 'aggregated-node-keyShape',\r\n            });\r\n\r\n            let labelStyle = {};\r\n            if (cfg.labelCfg) {\r\n                labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);\r\n            }\r\n\r\n            if (cfg.label) {\r\n                const text = cfg.label;\r\n                let labelStyle = {};\r\n                let refY = 0;\r\n                if (cfg.labelCfg) {\r\n                    labelStyle = Object.assign(labelStyle, cfg.labelCfg.style);\r\n                    refY += cfg.labelCfg.refY || 0;\r\n                }\r\n                let offsetY = 0;\r\n                const fontSize = labelStyle.fontSize < 8 ? 8 : labelStyle.fontSize;\r\n                const lineNum = cfg.labelLineNum || 1;\r\n                offsetY = lineNum * (fontSize || 12);\r\n                group.addShape('text', {\r\n                    attrs: {\r\n                        text,\r\n                        x: 0,\r\n                        y: r + refY + offsetY + 5,\r\n                        textAlign: 'center',\r\n                        textBaseLine: 'alphabetic',\r\n                        cursor: 'pointer',\r\n                        fontSize,\r\n                        fill: '#fff',\r\n                        opacity: 0.85,\r\n                        fontWeight: 400,\r\n                        stroke: global.edge.labelCfg.style.stroke,\r\n                    },\r\n                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\r\n                    name: 'text-shape',\r\n                    className: 'text-shape',\r\n                });\r\n            }\r\n\r\n            // tag for new node\r\n            if (cfg.new) {\r\n                group.addShape('circle', {\r\n                    attrs: {\r\n                        x: r - 3,\r\n                        y: -r + 3,\r\n                        r: 4,\r\n                        fill: '#6DD400',\r\n                        lineWidth: 0.5,\r\n                        stroke: '#FFFFFF',\r\n                    },\r\n                    // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\r\n                    name: 'typeNode-tag-circle',\r\n                });\r\n            }\r\n\r\n            return keyShape;\r\n        },\r\n        setState: (name, value, item) => {\r\n            const group = item.get('group');\r\n            if (name === 'layoutEnd' && value) {\r\n                const labelShape = group.find((e) => e.get('name') === 'text-shape');\r\n                if (labelShape) labelShape.set('visible', true);\r\n            } else if (name === 'hover') {\r\n                if (item.hasState('focus')) {\r\n                    return;\r\n                }\r\n                const halo = group.find((e) => e.get('name') === 'halo-shape');\r\n                const keyShape = item.getKeyShape();\r\n                const colorSet = item.getModel().colorSet || colorSets[0];\r\n                if (value) {\r\n                    halo && halo.show();\r\n                    keyShape.attr('fill', colorSet.activeFill);\r\n                } else {\r\n                    halo && halo.hide();\r\n                    keyShape.attr('fill', colorSet.mainFill);\r\n                }\r\n            } else if (name === 'focus') {\r\n                const stroke = group.find((e) => e.get('name') === 'stroke-shape');\r\n                const label = group.find((e) => e.get('name') === 'text-shape');\r\n                const keyShape = item.getKeyShape();\r\n                const colorSet = item.getModel().colorSet || colorSets[0];\r\n                if (value) {\r\n                    stroke && stroke.show();\r\n                    keyShape.attr('fill', colorSet.selectedFill);\r\n                    label && label.attr('fontWeight', 800);\r\n                } else {\r\n                    stroke && stroke.hide();\r\n                    keyShape.attr('fill', colorSet.mainFill); // '#2B384E'\r\n                    label && label.attr('fontWeight', 400);\r\n                }\r\n            }\r\n        },\r\n        update: undefined,\r\n    },\r\n    '普通节点',\r\n); // 这样可以继承 aggregated-node 的 setState\r\n\r\n\r\nG6.registerEdge(\r\n    'ClusterEdge', {\r\n        setState: (name, value, item) => {\r\n            const group = item.get('group');\r\n            const model = item.getModel();\r\n            if (name === 'focus') {\r\n                const back = group.find((ele) => ele.get('name') === 'back-line');\r\n                if (back) {\r\n                    back.stopAnimate();\r\n                    back.remove();\r\n                    back.destroy();\r\n                }\r\n                const keyShape = group.find((ele) => ele.get('name') === 'edge-shape');\r\n                const arrow = model.style.endArrow;\r\n                if (value) {\r\n                    if (keyShape.cfg.animation) {\r\n                        keyShape.stopAnimate(true);\r\n                    }\r\n                    keyShape.attr({\r\n                        strokeOpacity: animateOpacity,\r\n                        opacity: animateOpacity,\r\n                        stroke: '#fff',\r\n                        endArrow: {\r\n                            ...arrow,\r\n                            stroke: '#fff',\r\n                            fill: '#fff',\r\n                        },\r\n                    });\r\n                    if (model.isReal) {\r\n                        const { lineWidth, path, endArrow, stroke } = keyShape.attr();\r\n                        const back = group.addShape('path', {\r\n                            attrs: {\r\n                                lineWidth,\r\n                                path,\r\n                                stroke,\r\n                                endArrow,\r\n                                opacity: animateBackOpacity,\r\n                            },\r\n                            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\r\n                            name: 'back-line',\r\n                        });\r\n                        back.toBack();\r\n                        const length = keyShape.getTotalLength();\r\n                        keyShape.animate(\r\n                            (ratio) => {\r\n                                // the operations in each frame. Ratio ranges from 0 to 1 indicating the prograss of the animation. Returns the modified configurations\r\n                                const startLen = ratio * length;\r\n                                // Calculate the lineDash\r\n                                const cfg = {\r\n                                    lineDash: [startLen, length - startLen],\r\n                                };\r\n                                return cfg;\r\n                            }, {\r\n                                repeat: true, // Whether executes the animation repeatly\r\n                                duration, // the duration for executing once\r\n                            },\r\n                        );\r\n                    } else {\r\n                        let index = 0;\r\n                        const lineDash = keyShape.attr('lineDash');\r\n                        const totalLength = lineDash[0] + lineDash[1];\r\n                        keyShape.animate(\r\n                            () => {\r\n                                index++;\r\n                                if (index > totalLength) {\r\n                                    index = 0;\r\n                                }\r\n                                const res = {\r\n                                    lineDash,\r\n                                    lineDashOffset: -index,\r\n                                };\r\n                                // returns the modified configurations here, lineDash and lineDashOffset here\r\n                                return res;\r\n                            }, {\r\n                                repeat: true, // whether executes the animation repeatly\r\n                                duration, // the duration for executing once\r\n                            },\r\n                        );\r\n                    }\r\n                } else {\r\n                    keyShape.stopAnimate();\r\n                    const stroke = '#acaeaf';\r\n                    const opacity = model.isReal ? realEdgeOpacity : virtualEdgeOpacity;\r\n                    keyShape.attr({\r\n                        stroke,\r\n                        strokeOpacity: opacity,\r\n                        opacity,\r\n                        endArrow: {\r\n                            ...arrow,\r\n                            stroke,\r\n                            fill: stroke,\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n        },\r\n    },\r\n    'quadratic',\r\n);\r\n\r\n// 普通节点边\r\nG6.registerEdge(\r\n    'NodeEdge', {\r\n        setState: (name, value, item) => {\r\n            const group = item.get('group');\r\n            const model = item.getModel();\r\n            if (name === 'focus') {\r\n                const keyShape = group.find((ele) => ele.get('name') === 'edge-shape');\r\n                const back = group.find((ele) => ele.get('name') === 'back-line');\r\n\r\n\r\n                if (back) {\r\n                    back.stopAnimate();\r\n                    back.remove();\r\n                    back.destroy();\r\n                }\r\n                const arrow = model.style.endArrow;\r\n                if (value) {\r\n                    if (keyShape.cfg.animation) {\r\n                        keyShape.stopAnimate(true);\r\n                    }\r\n                    keyShape.attr({\r\n                        strokeOpacity: animateOpacity,\r\n                        opacity: animateOpacity,\r\n                        stroke: '#fff',\r\n                        endArrow: {\r\n                            ...arrow,\r\n                            stroke: '#fff',\r\n                            fill: '#fff',\r\n                        },\r\n                    });\r\n                    if (model.isReal) {\r\n                        const { path, stroke, lineWidth } = keyShape.attr();\r\n                        const back = group.addShape('path', {\r\n                            attrs: {\r\n                                path,\r\n                                stroke,\r\n                                lineWidth,\r\n                                opacity: animateBackOpacity,\r\n                            },\r\n                            // must be assigned in G6 3.3 and later versions. it can be any string you want, but should be unique in a custom item type\r\n                            name: 'back-line',\r\n                        });\r\n                        back.toBack();\r\n                        const length = keyShape.getTotalLength();\r\n                        keyShape.animate(\r\n                            (ratio) => {\r\n                                // the operations in each frame. Ratio ranges from 0 to 1 indicating the prograss of the animation. Returns the modified configurations\r\n                                const startLen = ratio * length;\r\n                                // Calculate the lineDash\r\n                                const cfg = {\r\n                                    lineDash: [startLen, length - startLen],\r\n                                };\r\n                                return cfg;\r\n                            }, {\r\n                                repeat: true, // Whether executes the animation repeatly\r\n                                duration, // the duration for executing once\r\n                            },\r\n                        );\r\n                    } else {\r\n                        const lineDash = keyShape.attr('lineDash');\r\n                        const totalLength = lineDash[0] + lineDash[1];\r\n                        let index = 0;\r\n                        keyShape.animate(\r\n                            () => {\r\n                                index++;\r\n                                if (index > totalLength) {\r\n                                    index = 0;\r\n                                }\r\n                                const res = {\r\n                                    lineDash,\r\n                                    lineDashOffset: -index,\r\n                                };\r\n                                // returns the modified configurations here, lineDash and lineDashOffset here\r\n                                return res;\r\n                            }, {\r\n                                repeat: true, // whether executes the animation repeatly\r\n                                duration, // the duration for executing once\r\n                            },\r\n                        );\r\n                    }\r\n                } else {\r\n                    keyShape.stopAnimate();\r\n                    const stroke = '#acaeaf';\r\n                    const opacity = model.isReal ? realEdgeOpacity : virtualEdgeOpacity;\r\n                    keyShape.attr({\r\n                        stroke,\r\n                        strokeOpacity: opacity,\r\n                        opacity: opacity,\r\n                        endArrow: {\r\n                            ...arrow,\r\n                            stroke,\r\n                            fill: stroke,\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n        },\r\n    },\r\n    'single-edge',\r\n);\r\n\r\nconst descendCompare = (p) => {\r\n    // 这是比较函数\r\n    return function(m, n) {\r\n        const a = m[p];\r\n        const b = n[p];\r\n        return b - a; // 降序\r\n    };\r\n};\r\n\r\nconst clearFocusItemState = (graph) => {\r\n    if (!graph) return;\r\n    clearFocusNodeState(graph);\r\n    clearFocusEdgeState(graph);\r\n};\r\n\r\n// 清除图上所有节点的 focus 状态及相应样式\r\nconst clearFocusNodeState = (graph) => {\r\n    const focusNodes = graph.findAllByState('node', 'focus');\r\n    focusNodes.forEach((fnode) => {\r\n        graph.setItemState(fnode, 'focus', false); // false\r\n    });\r\n};\r\n\r\n// 清除图上所有边的 focus 状态及相应样式\r\nconst clearFocusEdgeState = (graph) => {\r\n    const focusEdges = graph.findAllByState('edge', 'focus');\r\n    focusEdges.forEach((fedge) => {\r\n        graph.setItemState(fedge, 'focus', false);\r\n    });\r\n};\r\n\r\n// 截断长文本。length 为文本截断后长度，elipsis 是后缀\r\nconst formatText = (text, length = 5, elipsis = '...') => {\r\n    if (!text) return '';\r\n    if (text.length > length) {\r\n        return `${text.substr(0, length)}${elipsis}`;\r\n    }\r\n    return text;\r\n};\r\n\r\nconst labelFormatter = (text, minLength = 10) => {\r\n    if (text && text.split('').length > minLength) return `${text.substr(0, minLength)}...`;\r\n    return text;\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst processNodesEdges = (\r\n    nodes, // 节点列表\r\n    edges, // 边列表\r\n    width, // 图表宽度\r\n    height, // 图表高度\r\n    largeGraphMode, // 是否是大图模式\r\n    edgeLabelVisible, // 是否展开边标签\r\n    isNewGraph = false, // 是否是新图\r\n) => {\r\n    // 如果节点列表为空，则返回空对象\r\n    if (!nodes || nodes.length === 0) return {};\r\n\r\n    // 定义当前节点的映射表以及最大节点数\r\n    const currentNodeMap = {};\r\n    let maxNodeCount = -Infinity;\r\n\r\n    // 定义一些常量\r\n    const paddingRatio = 0.3;\r\n    const paddingLeft = paddingRatio * width;\r\n    const paddingTop = paddingRatio * height;\r\n\r\n\r\n    // 对每个节点进行处理\r\n    nodes.forEach((node) => {\r\n        // 设置节点的类型和标签\r\n        node.type = node.level === 0 ? '普通节点' : '聚合节点';\r\n        node.isReal = node.level === 0 ? true : false;\r\n\r\n        /*   node.labelLineNum = undefined; */\r\n\r\n        node.degree = 0;\r\n        node.inDegree = 0;\r\n        node.outDegree = 0;\r\n\r\n        // 防止节点id重复，如果节点id已存在，则在其后添加一个随机数\r\n        if (currentNodeMap[node.id]) {\r\n            console.warn('node exists already!', node.id);\r\n            node.id = `${node.id}${Math.random()}`;\r\n        }\r\n\r\n        // 将节点加入当前节点映射表中\r\n        currentNodeMap[node.id] = node;\r\n\r\n        // 计算最大节点数\r\n        if (node.count > maxNodeCount) maxNodeCount = node.count;\r\n\r\n        // 如果已经有了缓存位置，则使用缓存位置\r\n        const cachePosition = cachePositions ? cachePositions[node.id] : undefined;\r\n        if (cachePosition) {\r\n            node.x = cachePosition.x;\r\n            node.y = cachePosition.y;\r\n            node.new = false;\r\n        } else {\r\n            // 否则随机生成位置\r\n            node.new = isNewGraph ? false : true;\r\n            if (manipulatePosition && !node.x && !node.y) {\r\n                node.x = manipulatePosition.x + 10 * Math.cos(Math.random() * Math.PI * 2);\r\n                node.y = manipulatePosition.y + 10 * Math.sin(Math.random() * Math.PI * 2);\r\n            }\r\n        }\r\n    });\r\n\r\n    let maxCount = -Infinity;\r\n    let minCount = Infinity;\r\n    // let maxCount = 0;\r\n    edges.forEach((edge) => {\r\n        // to avoid the dulplicated id to nodes\r\n        if (!edge.id) edge.id = uniqueId('edge');\r\n        else if (edge.id.split('-')[0] !== 'edge') edge.id = `edge-${edge.id}`;\r\n        // TODO: delete the following line after the queried data is correct\r\n        if (!currentNodeMap[edge.source] || !currentNodeMap[edge.target]) {\r\n            console.warn('edge source target does not exist', edge.source, edge.target, edge.id);\r\n            return;\r\n        }\r\n        const sourceNode = currentNodeMap[edge.source];\r\n        const targetNode = currentNodeMap[edge.target];\r\n\r\n        if (!sourceNode || !targetNode)\r\n            console.warn('source or target is not defined!!!', edge, sourceNode, targetNode);\r\n\r\n        // calculate the degree\r\n        sourceNode.degree++;\r\n        targetNode.degree++;\r\n        sourceNode.outDegree++;\r\n        targetNode.inDegree++;\r\n\r\n        if (edge.count > maxCount) maxCount = edge.count;\r\n        if (edge.count < minCount) minCount = edge.count;\r\n    });\r\n\r\n    nodes.sort(descendCompare(NODESIZEMAPPING));\r\n    const maxDegree = nodes[0].degree || 1;\r\n\r\n    const descreteNodes = [];\r\n    nodes.forEach((node) => {\r\n        // assign the size mapping to the outDegree\r\n        const countRatio = node.count / maxNodeCount;\r\n        const isRealNode = node.level === 0;\r\n        node.size = isRealNode ? (node.degree + 2) * 2 : node.count;\r\n        node.isReal = isRealNode;\r\n        node.labelCfg = {\r\n            position: 'bottom',\r\n            offset: 5,\r\n            style: {\r\n                fill: global.node.labelCfg.style.fill,\r\n                fontSize: 6 + countRatio * 6 || 12,\r\n                stroke: global.node.labelCfg.style.stroke,\r\n                lineWidth: 3,\r\n            },\r\n        };\r\n\r\n        if (!node.degree) {\r\n            descreteNodes.push(node);\r\n        }\r\n    });\r\n\r\n    const countRange = maxCount - minCount;\r\n    const minEdgeSize = 1;\r\n    const maxEdgeSize = 10;\r\n    const edgeSizeRange = maxEdgeSize - minEdgeSize;\r\n    edges.forEach((edge) => {\r\n        // set edges' style\r\n        const targetNode = currentNodeMap[edge.target];\r\n\r\n        const size = ((edge.count - minCount) / countRange) * edgeSizeRange + minEdgeSize || 1;\r\n        edge.size = size;\r\n\r\n        const arrowWidth = Math.max(size / 2 + 2, 3);\r\n        const arrowLength = 10;\r\n        const arrowBeging = targetNode.size + arrowLength;\r\n        let arrowPath = `M ${arrowBeging},0 L ${arrowBeging + arrowLength},-${arrowWidth} L ${arrowBeging + arrowLength\r\n            },${arrowWidth} Z`;\r\n        let d = targetNode.size / 2 + arrowLength;\r\n        if (edge.source === edge.target) {\r\n            edge.type = 'loop';\r\n            arrowPath = undefined;\r\n        }\r\n        const sourceNode = currentNodeMap[edge.source];\r\n        const isRealEdge = targetNode.isReal && sourceNode.isReal;\r\n        edge.isReal = isRealEdge;\r\n        const stroke = isRealEdge ? global.edge.style.realEdgeStroke : global.edge.style.stroke;\r\n        const opacity = isRealEdge ?\r\n            global.edge.style.realEdgeOpacity :\r\n            global.edge.style.strokeOpacity;\r\n        const dash = Math.max(size, 2);\r\n        const lineDash = isRealEdge ? undefined : [dash, dash];\r\n        edge.style = {\r\n            stroke,\r\n            strokeOpacity: opacity,\r\n            cursor: 'pointer',\r\n            lineAppendWidth: Math.max(edge.size || 5, 5),\r\n            fillOpacity: 1,\r\n            lineDash,\r\n            endArrow: arrowPath ? {\r\n                path: arrowPath,\r\n                d,\r\n                fill: stroke,\r\n                strokeOpacity: 0,\r\n            } : false,\r\n        };\r\n        edge.labelCfg = {\r\n            autoRotate: true,\r\n            style: {\r\n                stroke: global.edge.labelCfg.style.stroke,\r\n                fill: global.edge.labelCfg.style.fill,\r\n                lineWidth: 4,\r\n                fontSize: 12,\r\n                lineAppendWidth: 10,\r\n                opacity: 1,\r\n            },\r\n        };\r\n        if (!edge.orilabel) edge.orilabel = edge.label;\r\n        if (largeGraphMode || !edgeLabelVisible) edge.label = '';\r\n        else {\r\n            edge.label = labelFormatter(edge.label, labelMaxLength);\r\n        }\r\n\r\n        // arrange the other nodes around the hub\r\n        const sourceDis = sourceNode.size / 2 + 20;\r\n        const targetDis = targetNode.size / 2 + 20;\r\n        if (sourceNode.x && !targetNode.x) {\r\n            targetNode.x = sourceNode.x + sourceDis * Math.cos(Math.random() * Math.PI * 2);\r\n        }\r\n        if (sourceNode.y && !targetNode.y) {\r\n            targetNode.y = sourceNode.y + sourceDis * Math.sin(Math.random() * Math.PI * 2);\r\n        }\r\n        if (targetNode.x && !sourceNode.x) {\r\n            sourceNode.x = targetNode.x + targetDis * Math.cos(Math.random() * Math.PI * 2);\r\n        }\r\n        if (targetNode.y && !sourceNode.y) {\r\n            sourceNode.y = targetNode.y + targetDis * Math.sin(Math.random() * Math.PI * 2);\r\n        }\r\n\r\n        if (!sourceNode.x && !sourceNode.y && manipulatePosition) {\r\n            sourceNode.x = manipulatePosition.x + 30 * Math.cos(Math.random() * Math.PI * 2);\r\n            sourceNode.y = manipulatePosition.y + 30 * Math.sin(Math.random() * Math.PI * 2);\r\n        }\r\n        if (!targetNode.x && !targetNode.y && manipulatePosition) {\r\n            targetNode.x = manipulatePosition.x + 30 * Math.cos(Math.random() * Math.PI * 2);\r\n            targetNode.y = manipulatePosition.y + 30 * Math.sin(Math.random() * Math.PI * 2);\r\n        }\r\n    });\r\n\r\n    descreteNodeCenter = {\r\n        x: width - paddingLeft,\r\n        y: height - paddingTop,\r\n    };\r\n    descreteNodes.forEach((node) => {\r\n        if (!node.x && !node.y) {\r\n            node.x = descreteNodeCenter.x + 30 * Math.cos(Math.random() * Math.PI * 2);\r\n            node.y = descreteNodeCenter.y + 30 * Math.sin(Math.random() * Math.PI * 2);\r\n        }\r\n    });\r\n\r\n    G6.Util.processParallelEdges(edges, 12.5, 'ClusterEdge', 'NodeEdge');\r\n    return {\r\n        maxDegree,\r\n        edges,\r\n    };\r\n};\r\n\r\n/**\r\n * 获取 Force 布局的配置信息\r\n * @param graph - G6 图实例对象\r\n * @param largeGraphMode - 是否是大数据量模式\r\n * @param configSettings - 配置项\r\n * @returns {Object} Force 布局的配置对象\r\n */\r\nconst getForceLayoutConfig = (graph, largeGraphMode, configSettings) => {\r\n    // 解构出配置项中的参数\r\n    let {\r\n        linkDistance,\r\n        edgeStrength,\r\n        nodeStrength,\r\n        nodeSpacing,\r\n        preventOverlap,\r\n        nodeSize,\r\n        collideStrength,\r\n        alpha,\r\n        alphaDecay,\r\n        alphaMin,\r\n    } = configSettings || { preventOverlap: true };\r\n\r\n    // 若参数未设置，设置默认值\r\n    if (!linkDistance && linkDistance !== 0) linkDistance = 150;\r\n    if (!edgeStrength && edgeStrength !== 0) edgeStrength = 40;\r\n    if (!nodeStrength && nodeStrength !== 0) nodeStrength = 200;\r\n    if (!nodeSpacing && nodeSpacing !== 0) nodeSpacing = 5;\r\n\r\n    // Force 布局配置项\r\n    const config = {\r\n        type: 'gForce',\r\n        minMovement: 0.01,\r\n        maxIteration: 2000,\r\n        preventOverlap,\r\n        nodeSize: 100,\r\n        damping: 0.99,\r\n        linkDistance: (d) => {\r\n            let dist = linkDistance;\r\n            const sourceNode = nodeMap[d.source] || aggregatedNodeMap[d.source];\r\n            const targetNode = nodeMap[d.target] || aggregatedNodeMap[d.target];\r\n            //若两端都是聚合点\r\n            if (sourceNode.level && targetNode.level) dist = linkDistance * 3;\r\n            // 若一端是聚合点，一端是真实节点\r\n            else if (sourceNode.level || targetNode.level) dist = linkDistance * 1.5;\r\n            if (!sourceNode.level && !targetNode.level) dist = linkDistance * 0.3;\r\n            return dist;\r\n        },\r\n        edgeStrength: (d) => {\r\n            const sourceNode = nodeMap[d.source] || aggregatedNodeMap[d.source];\r\n            const targetNode = nodeMap[d.target] || aggregatedNodeMap[d.target];\r\n            // 聚合节点之间的引力小\r\n            if (sourceNode.level && targetNode.level) return edgeStrength;\r\n            // 聚合节点与真实节点之间引力大\r\n            if (sourceNode.level || targetNode.level) return edgeStrength * 2;\r\n            return edgeStrength;\r\n        },\r\n        nodeStrength: (d) => {\r\n\r\n            if (d.degree === 1) return 100;\r\n            if (d.category === '产业') return nodeStrength * 3;\r\n            if (d.level) return nodeStrength * 15;\r\n            return nodeStrength;\r\n        },\r\n        /*   nodeSize: (d) => {\r\n              if (!nodeSize && d.size) return d.size;\r\n             \r\n          }, */\r\n        nodeSpacing: (d) => {\r\n\r\n            if (d.degree === 0) return nodeSpacing * 2;\r\n            if (d.level) return 400;\r\n            return nodeSpacing;\r\n\r\n        },\r\n        // 布局结束后的回调函数\r\n        onLayoutEnd: () => {\r\n            if (largeGraphMode) {\r\n                graph.getEdges().forEach((edge) => {\r\n                    if (!edge.orilabel) return;\r\n                    edge.update({\r\n                        label: labelFormatter(edge.orilabel, labelMaxLength),\r\n                    });\r\n                });\r\n            }\r\n        },\r\n        tick: () => {\r\n            graph.refreshPositions();\r\n        },\r\n    };\r\n\r\n    if (nodeSize) config['nodeSize'] = nodeSize;\r\n    if (collideStrength) config['collideStrength'] = collideStrength;\r\n    if (alpha) config['alpha'] = alpha;\r\n    if (alphaDecay) config['alphaDecay'] = alphaDecay;\r\n    if (alphaMin) config['alphaMin'] = alphaMin;\r\n\r\n    return config;\r\n};\r\n\r\nconst hideItems = (graph) => {\r\n    hiddenItemIds.forEach((id) => {\r\n        graph.hideItem(id);\r\n    });\r\n};\r\n\r\nconst showItems = (graph) => {\r\n    graph.getNodes().forEach((node) => {\r\n        if (!node.isVisible()) graph.showItem(node);\r\n    });\r\n    graph.getEdges().forEach((edge) => {\r\n        if (!edge.isVisible()) edge.showItem(edge);\r\n    });\r\n    hiddenItemIds = [];\r\n};\r\n\r\n// 定义 handleRefreshGraph 函数，更新 Graphin 实例中的图数据\r\nconst handleRefreshGraph = (\r\n    graph, // Graphin 实例对象\r\n    graphData, // 更新后的图数据\r\n    width, // Graphin 实例宽度\r\n    height, // Graphin 实例高度\r\n    largeGraphMode, // 是否开启大规模图模式\r\n    edgeLabelVisible, // 边标签是否可见\r\n    isNewGraph, // 是否是新的图数据\r\n) => {\r\n    // 如果图数据或 Graphin 实例不存在，则直接返回\r\n    if (!graphData || !graph) return;\r\n    // 清除所有节点和边的焦点状态\r\n    clearFocusItemState(graph);\r\n    // 重置过滤\r\n    graph.getNodes().forEach((node) => {\r\n        if (!node.isVisible()) node.show();\r\n    });\r\n    graph.getEdges().forEach((edge) => {\r\n        if (!edge.isVisible()) edge.show();\r\n    });\r\n\r\n    let nodes = [],\r\n        edges = [];\r\n\r\n    // 将更新后的图数据中的节点数据赋值给 nodes 变量\r\n    nodes = graphData.nodes;\r\n    // 对节点和边进行处理\r\n    const processRes = processNodesEdges(\r\n        nodes,\r\n        graphData.edges || [],\r\n        width,\r\n        height,\r\n        largeGraphMode,\r\n        edgeLabelVisible,\r\n        isNewGraph,\r\n    );\r\n    // 将处理后的边数据赋值给 edges 变量\r\n    edges = processRes.edges;\r\n\r\n    // 更新 Graphin 实例中的图数据\r\n    graph.changeData({ nodes, edges });\r\n\r\n    // 隐藏所有节点和边\r\n    hideItems(graph);\r\n    // 将所有节点移到前面\r\n    graph.getNodes().forEach((node) => {\r\n        node.toFront();\r\n    });\r\n\r\n    // 初始化布局\r\n    layout.instance.init({\r\n        nodes: graphData.nodes, // 节点数据\r\n        edges, // 边数据\r\n    });\r\n\r\n    // 设置布局参数\r\n    layout.instance.minMovement = 0.0001;\r\n    layout.instance.getMass = (d) => {\r\n        const cachePosition = cachePositions[d.id];\r\n        if (cachePosition) return 5;\r\n        return 1;\r\n    };\r\n\r\n    // 执行布局算法\r\n    layout.instance.execute();\r\n    // 返回更新后的节点和边数据\r\n    return { nodes, edges };\r\n};\r\n\r\n/**\r\n * 根据聚合数据和原始数据生成节点和边数据\r\n * @param {Object} aggregatedData 聚合数据\r\n * @param {Object} originData 原始数据\r\n * @param {Object} nodeMap 节点映射表\r\n * @param {Object} aggregatedNodeMap 聚合节点映射表\r\n * @param {Array} expandArray 展开数组\r\n * @param {Array} collapseArray 收缩数组\r\n * @returns {Object} 包含节点和边数据的对象\r\n */\r\nconst getMixedGraph = (\r\n    aggregatedData,\r\n    originData,\r\n    nodeMap,\r\n    aggregatedNodeMap,\r\n    expandArray,\r\n    collapseArray,\r\n) => {\r\n    let nodes = [],\r\n        edges = [];\r\n\r\n    const expandMap = {}, // 存储展开数组的映射表\r\n        collapseMap = {}; // 存储收缩数组的映射表\r\n    expandArray.forEach((expandModel) => {\r\n        expandMap[expandModel.id] = true;\r\n    });\r\n    collapseArray.forEach((collapseModel) => {\r\n        collapseMap[collapseModel.id] = true;\r\n    });\r\n\r\n    // 遍历聚合数据中的每个聚类，根据展开和收缩数组将节点分为两类\r\n    aggregatedData.clusters.forEach((cluster, i) => {\r\n        if (expandMap[cluster.id]) { // 如果当前聚类在展开数组中，将其节点全部加入 nodes 数组\r\n            nodes = nodes.concat(cluster.nodes);\r\n            aggregatedNodeMap[cluster.id].expanded = true; // 更新聚合节点映射表中该聚类的展开状态为 true\r\n        } else { // 否则将聚合节点本身加入 nodes 数组\r\n            nodes.push(aggregatedNodeMap[cluster.id]);\r\n            aggregatedNodeMap[cluster.id].expanded = false; // 更新聚合节点映射表中该聚类的展开状态为 false\r\n        }\r\n    });\r\n    originData.edges.forEach((edge) => {\r\n        const isSourceInExpandArray = expandMap[nodeMap[edge.source].clusterId];\r\n        const isTargetInExpandArray = expandMap[nodeMap[edge.target].clusterId];\r\n        if (isSourceInExpandArray && isTargetInExpandArray) {\r\n            edges.push(edge);\r\n        } else if (isSourceInExpandArray) {\r\n            const targetClusterId = nodeMap[edge.target].clusterId;\r\n            const vedge = {\r\n                source: edge.source,\r\n                target: targetClusterId,\r\n                id: uniqueId('edge'),\r\n                label: '',\r\n            };\r\n            edges.push(vedge);\r\n        } else if (isTargetInExpandArray) {\r\n            const sourceClusterId = nodeMap[edge.source].clusterId;\r\n            const vedge = {\r\n                target: edge.target,\r\n                source: sourceClusterId,\r\n                id: uniqueId('edge'),\r\n                label: '',\r\n            };\r\n            edges.push(vedge);\r\n        }\r\n    });\r\n    aggregatedData.clusterEdges.forEach((edge) => {\r\n        if (expandMap[edge.source] || expandMap[edge.target]) return;\r\n        else edges.push(edge);\r\n    });\r\n\r\n    return { nodes, edges };\r\n\r\n};\r\n\r\n\r\n\r\n\r\nconst examAncestors = (model, expandedArray, length, keepTags) => {\r\n    for (let i = 0; i < length; i++) {\r\n        const expandedNode = expandedArray[i];\r\n        if (!keepTags[i] && model.parentId === expandedNode.id) {\r\n            keepTags[i] = true; // 需要被保留\r\n            examAncestors(expandedNode, expandedArray, length, keepTags);\r\n            break;\r\n        }\r\n    }\r\n};\r\n\r\nconst manageExpandCollapseArray = (nodeNumber, model, collapseArray, expandArray) => {\r\n    manipulatePosition = { x: model.x, y: model.y };\r\n\r\n    // 维护 expandArray，若当前画布节点数高于上限，移出 expandedArray 中非 model 祖先的节点)\r\n    if (nodeNumber > NODE_LIMIT) {\r\n        // 若 keepTags[i] 为 true，则 expandedArray 的第 i 个节点需要被保留\r\n        const keepTags = {};\r\n        const expandLen = expandArray.length;\r\n        // 检查 X 的所有祖先并标记 keepTags\r\n        examAncestors(model, expandArray, expandLen, keepTags);\r\n        // 寻找 expandedArray 中第一个 keepTags 不为 true 的点\r\n        let shiftNodeIdx = -1;\r\n        for (let i = 0; i < expandLen; i++) {\r\n            if (!keepTags[i]) {\r\n                shiftNodeIdx = i;\r\n                break;\r\n            }\r\n        }\r\n        // 如果有符合条件的节点，将其从 expandedArray 中移除\r\n        if (shiftNodeIdx !== -1) {\r\n            let foundNode = expandArray[shiftNodeIdx];\r\n            if (foundNode.level === 2) {\r\n                let foundLevel1 = false;\r\n                // 找到 expandedArray 中 parentId = foundNode.id 且 level = 1 的第一个节点\r\n                for (let i = 0; i < expandLen; i++) {\r\n                    const eNode = expandArray[i];\r\n                    if (eNode.parentId === foundNode.id && eNode.level === 1) {\r\n                        foundLevel1 = true;\r\n                        foundNode = eNode;\r\n                        expandArray.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n                // 若未找到，则 foundNode 不变, 直接删去 foundNode\r\n                if (!foundLevel1) expandArray.splice(shiftNodeIdx, 1);\r\n            } else {\r\n                // 直接删去 foundNode\r\n                expandArray.splice(shiftNodeIdx, 1);\r\n            }\r\n            // const removedNode = expandedArray.splice(shiftNodeIdx, 1); // splice returns an array\r\n            const idSplits = foundNode.id.split('-');\r\n            let collapseNodeId;\r\n            // 去掉最后一个后缀\r\n            for (let i = 0; i < idSplits.length - 1; i++) {\r\n                const str = idSplits[i];\r\n                if (collapseNodeId) collapseNodeId = `${collapseNodeId}-${str}`;\r\n                else collapseNodeId = str;\r\n            }\r\n            const collapseNode = {\r\n                id: collapseNodeId,\r\n                parentId: foundNode.id,\r\n                level: foundNode.level - 1,\r\n            };\r\n            collapseArray.push(collapseNode);\r\n        }\r\n    }\r\n\r\n    const currentNode = {\r\n        id: model.id,\r\n        level: model.level,\r\n        parentId: model.parentId,\r\n    };\r\n\r\n    // 加入当前需要展开的节点\r\n    expandArray.push(currentNode);\r\n\r\n    graph.get('canvas').setCursor('default');\r\n    return { expandArray, collapseArray };\r\n};\r\n\r\nconst cacheNodePositions = (nodes) => {\r\n    const positionMap = {};\r\n    const nodeLength = nodes.length;\r\n    for (let i = 0; i < nodeLength; i++) {\r\n        const node = nodes[i].getModel();\r\n        positionMap[node.id] = {\r\n            x: node.x,\r\n            y: node.y,\r\n            level: node.level,\r\n        };\r\n    }\r\n    return positionMap;\r\n};\r\n\r\nconst stopLayout = () => {\r\n    layout.instance.stop();\r\n};\r\n\r\nconst bindListener = (graph) => {\r\n    graph.on('keydown', (evt) => {\r\n        const code = evt.key;\r\n        if (!code) {\r\n            return;\r\n        }\r\n        if (code.toLowerCase() === 'shift') {\r\n            shiftKeydown = true;\r\n        } else {\r\n            shiftKeydown = false;\r\n        }\r\n    });\r\n    graph.on('keyup', (evt) => {\r\n        const code = evt.key;\r\n        if (!code) {\r\n            return;\r\n        }\r\n        if (code.toLowerCase() === 'shift') {\r\n            shiftKeydown = false;\r\n        }\r\n    });\r\n    graph.on('node:mouseenter', (evt) => {\r\n        const { item } = evt;\r\n        const model = item.getModel();\r\n        const currentLabel = model.label;\r\n        model.oriFontSize = model.labelCfg.style.fontSize;\r\n        item.update({\r\n            label: model.orilabel,\r\n        });\r\n\r\n        model.orilabel = currentLabel;\r\n\r\n        graph.setItemState(item, 'hover', true);\r\n        item.toFront();\r\n    });\r\n\r\n    graph.on('node:mouseleave', (evt) => {\r\n        const { item } = evt;\r\n        const model = item.getModel();\r\n        const currentLabel = model.label;\r\n        item.update({\r\n            label: model.orilabel,\r\n        });\r\n        model.orilabel = currentLabel;\r\n\r\n\r\n\r\n        graph.setItemState(item, 'hover', false);\r\n    });\r\n\r\n    graph.on('edge:mouseenter', (evt) => {\r\n        const { item } = evt;\r\n        const model = item.getModel();\r\n        const currentLabel = model.label;\r\n        item.update({\r\n            label: model.orilabel,\r\n        });\r\n        model.orilabel = currentLabel;\r\n        item.toFront();\r\n        item.getSource().toFront();\r\n        item.getTarget().toFront();\r\n\r\n    });\r\n\r\n    graph.on('edge:mouseleave', (evt) => {\r\n        const { item } = evt;\r\n        const model = item.getModel();\r\n        const currentLabel = model.label;\r\n        item.update({\r\n            label: model.orilabel,\r\n        });\r\n        model.orilabel = currentLabel;\r\n    });\r\n    graph.on('node:click', (evt) => {\r\n        stopLayout();\r\n        if (!shiftKeydown) clearFocusItemState(graph);\r\n        else clearFocusEdgeState(graph);\r\n        const { item } = evt;\r\n\r\n        // highlight the clicked node, it is down by click-select\r\n        graph.setItemState(item, 'focus', true);\r\n\r\n        if (!shiftKeydown) {\r\n            // 将相关边也高亮\r\n            const relatedEdges = item.getEdges();\r\n            relatedEdges.forEach((edge) => {\r\n                graph.setItemState(edge, 'focus', true);\r\n\r\n\r\n            });\r\n\r\n            // 将相关节点也高亮\r\n            const relatedNodes = item.getNeighbors().filter(node => node.getModel().level === 0);\r\n\r\n\r\n            relatedNodes.forEach((node) => {\r\n\r\n                graph.setItemState(node, 'focus', true);\r\n            });\r\n        }\r\n    });\r\n\r\n\r\n    // click edge to show the detail of integrated edge drawer\r\n    graph.on('edge:click', (evt) => {\r\n        stopLayout();\r\n        if (!shiftKeydown) clearFocusItemState(graph);\r\n        const { item } = evt;\r\n        // highlight the clicked edge\r\n        graph.setItemState(item, 'focus', true);\r\n    });\r\n\r\n    // click canvas to cancel all the focus state\r\n    graph.on('canvas:click', (evt) => {\r\n        clearFocusItemState(graph);\r\n        console.log(graph.getGroup(), graph.getGroup().getBBox(), graph.getGroup().getCanvasBBox());\r\n\r\n    });\r\n};\r\n\r\n\r\nconst subjectMap = {\r\n    '产业': 0,\r\n    '技术': 1,\r\n    '企业': 2,\r\n    '专利': 3,\r\n    '产品': 4,\r\n    '聚合节点': 5\r\n};\r\n\r\n\r\n\r\nconst industryToClusterId = {\r\n    \"原材料\": 'cluster1',\r\n    '组件': 'cluster2',\r\n    \"整车\": 'cluster3',\r\n    '市场服务': 'cluster4',\r\n    undefined: '未定义'\r\n};\r\nconst clusterIdToIndustry = {};\r\nfor (const industry in industryToClusterId) {\r\n    const clusterId = industryToClusterId[industry];\r\n    clusterIdToIndustry[clusterId] = industry;\r\n}\r\n\r\nfunction clusterByIndustry(data) {\r\n    const industryMap = new Map();\r\n    data.nodes.forEach(node => {\r\n        const industry = node.belongsto;\r\n        if (!industryMap.has(industry)) {\r\n            const clusterId = `cluster${industryMap.size + 1}`;\r\n            industryMap.set(industry, { id: clusterId, sumTot: 0, nodes: [] });\r\n        }\r\n        const cluster = industryMap.get(industry);\r\n        cluster.nodes.push({...node, clusterId: cluster.id });\r\n        cluster.sumTot++;\r\n    });\r\n\r\n    const clusters = Array.from(industryMap.values());\r\n    const clusterEdges = [];\r\n    const edgeMap = new Map();\r\n\r\n    data.edges.forEach((edge) => {\r\n        const sourceNode = data.nodes.find((node) => node.id === edge.source);\r\n        const targetNode = data.nodes.find((node) => node.id === edge.target);\r\n\r\n        const sourceClusterId = industryToClusterId[sourceNode.belongsto];\r\n        const targetClusterId = industryToClusterId[targetNode.belongsto];\r\n        const edgeKey = `${sourceClusterId}-${targetClusterId}`;\r\n        const reverseEdgeKey = `${targetClusterId}-${sourceClusterId}`;\r\n\r\n        if (edgeMap.has(edgeKey)) {\r\n            const edge = edgeMap.get(edgeKey);\r\n            edge.count += 1;\r\n        } else if (edgeMap.has(reverseEdgeKey)) {\r\n            const edge = edgeMap.get(reverseEdgeKey);\r\n            edge.count += 1;\r\n        } else {\r\n            edgeMap.set(edgeKey, { source: sourceClusterId, target: targetClusterId, count: 1 });\r\n        }\r\n    });\r\n\r\n    clusterEdges.push(...edgeMap.values());\r\n\r\n    return { clusters, clusterEdges };\r\n}\r\n\r\nconst filenames = ['./data/industries.json', './data/enterprises.json', 'data/tech_words.json', 'data/industries_to_techwords.json', './data/industries_to_industries.json', './data/industries_to_enterprises.json', 'data/techwords_to_industries.json'];\r\nconst getNeighborMixedGraph = (\r\n    centerNodeModel,\r\n    neighborType,\r\n    originData,\r\n    clusteredData,\r\n    currentData,\r\n    nodeMap,\r\n    aggregatedNodeMap,\r\n    maxNeighborNumPerNode,\r\n) => {\r\n    // update the manipulate position for center gravity of the new nodes\r\n    manipulatePosition = { x: centerNodeModel.x, y: centerNodeModel.y };\r\n\r\n    // the neighborSubGraph does not include the centerNodeModel. the elements are all generated new nodes and edges\r\n\r\n\r\n    const neighborSubGraph = generateNeighbors(centerNodeModel, maxNeighborNumPerNode, neighborType);\r\n    console.log(neighborSubGraph)\r\n        // update the origin data\r\n    originData.nodes = originData.nodes.concat(neighborSubGraph.nodes);\r\n    originData.edges = originData.edges.concat(neighborSubGraph.edges);\r\n    // update the origin nodeMap\r\n    neighborSubGraph.nodes.forEach((node) => {\r\n        nodeMap[node.id] = node;\r\n    });\r\n    // update the clusteredData\r\n    const clusterId = centerNodeModel.clusterId;\r\n    clusteredData.clusters.forEach((cluster) => {\r\n        if (cluster.id !== clusterId) return;\r\n        cluster.nodes = cluster.nodes.concat(neighborSubGraph.nodes);\r\n        cluster.sumTot += neighborSubGraph.edges.length;\r\n    });\r\n    // update the count\r\n    aggregatedNodeMap[clusterId].count += neighborSubGraph.nodes.length;\r\n\r\n    // Filter out the nodes that already exist in the currentData\r\n    const newNodes = neighborSubGraph.nodes.filter((node) => !currentData.nodes.some((n) => n.id === node.id));\r\n    const newEdges = neighborSubGraph.edges.filter((edge) => !currentData.edges.some((n) => n.id === edge.id));;\r\n\r\n    currentData.nodes = currentData.nodes.concat(newNodes);\r\n    currentData.edges = currentData.edges.concat(newEdges);\r\n    return currentData;\r\n};\r\n\r\n\r\n/**\r\n * 生成邻居节点\r\n * @param {Object} centerNodeModel 中心节点对象    \r\n * @param {number} maxNeighborNumPerNode 每个节点最多的邻居节点数量\r\n * @param {string} type 生成节点的类型\r\n * @returns {Object} 生成的节点和边对象\r\n */\r\nconst generateNeighbors = (centerNodeModel, maxNeighborNumPerNode = 10, category) => {\r\n    // 如果层数小于等于 0，则返回 undefined\r\n    let generatedData = null;\r\n\r\n\r\n    if (generatedData) {\r\n        return generatedData;\r\n    }\r\n    // 初始化节点数组和边数组\r\n    let nodes = [],\r\n        edges = [];\r\n    // 获取中心节点的簇 ID 和 ID\r\n    const clusterId = centerNodeModel.clusterId;\r\n    const centerId = centerNodeModel.id;\r\n    // 随机生成邻居节点的数量\r\n    const neighborNum = Math.ceil(Math.random() * maxNeighborNumPerNode);\r\n    // 循环生成技术邻居节点\r\n\r\n    for (let i = 0; i < neighborNum; i++) {\r\n        // 定义一个新的邻居节点，并设置属性\r\n        const neighborNode = {\r\n            id: category === '专利' ? generateRandomPatentName() : products[Math.floor(Math.random() * products.length)],\r\n            clusterId,\r\n            level: 0,\r\n            category: category,\r\n\r\n            colorSet: category === '专利' ? colorSets[3] : colorSets[4],\r\n\r\n        };\r\n\r\n        // 将新的邻居节点添加到节点数组中\r\n        nodes.push(neighborNode);\r\n        nodes.forEach((node) => {\r\n                node.orilabel = node.id;\r\n                node.label = labelFormatter(node.orilabel, 5);\r\n            })\r\n            // 随机生成边的方向\r\n\r\n        // 根据方向设置边的起点和终点\r\n        const source = centerId;\r\n        const target = neighborNode.id;\r\n        // 定义一条新的边，并设置属性\r\n        const neighborEdge = {\r\n            id: `${source}-${target}`, // 通过 uniqueId 函数生成唯一 ID\r\n            source,\r\n            target,\r\n            label: centerNodeModel.category === '技术' ? \"相关专利\" : \"主营产品\",\r\n        };\r\n        // 将新的边添加到边数组中\r\n        edges.push(neighborEdge);\r\n\r\n\r\n    }\r\n\r\n    // 返回生成的节点数组和边数组\r\n    return { nodes, edges };\r\n};\r\n\r\nPromise.all(filenames.map(filename => fetch(filename).then(response => response.json())))\r\n    .then(dataArr => {\r\n        const data = dataArr.reduce((acc, data) => {\r\n            if (data.nodes) {\r\n                acc.nodes.push(...data.nodes);\r\n            }\r\n            if (data.edges) {\r\n                acc.edges.push(...data.edges);\r\n            }\r\n            return acc;\r\n        }, { nodes: [], edges: [] });\r\n        const stats = {\r\n            industry: 0,\r\n            technology: 0,\r\n            enterprise: 0\r\n        };\r\n        data.nodes.forEach((node) => {\r\n            switch (node.category) {\r\n                case '产业':\r\n                    stats.industry += 1;\r\n                    break;\r\n                case '技术':\r\n                    stats.technology += 1;\r\n                    break;\r\n                case '企业':\r\n                    stats.enterprise += 1;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n        const typeConfigs = {\r\n            'indus': {\r\n                type: 'circle',\r\n                size: 20,\r\n                style: {\r\n                    fill: '#0f63a9',\r\n                    stroke: '#0f63a9',\r\n                    lineWidth: 2,\r\n                    opacity: 0.5,\r\n\r\n                }\r\n            },\r\n            'technology': {\r\n                type: 'circle',\r\n                size: 20,\r\n                style: {\r\n                    fill: '#eb4d4b',\r\n                    stroke: '#eb4d4b',\r\n                    lineWidth: 2,\r\n                    opacity: 0.5,\r\n                    stoke: '#dff9fb'\r\n                }\r\n            },\r\n            'enterprise': {\r\n                type: 'circle',\r\n                size: 20,\r\n                style: {\r\n                    fill: 'rgba(251, 197, 49,1.0)',\r\n                    stroke: 'rgba(251, 197, 49,1.0)',\r\n                    lineWidth: 2,\r\n                    opacity: 0.5\r\n                }\r\n            },\r\n            'patent': {\r\n                type: 'circle',\r\n                size: 20,\r\n                style: {\r\n                    fill: '#91cc75',\r\n                    stroke: '#91cc75',\r\n                    lineWidth: 2,\r\n                    opacity: 0.5\r\n                }\r\n            },\r\n            'product': {\r\n                type: 'circle',\r\n                size: 20,\r\n                style: {\r\n                    fill: ' rgba(156, 136, 255,1.0)',\r\n                    stroke: 'rgba(156, 136, 255,1.0)',\r\n                    lineWidth: 2,\r\n                    opacity: 0.5\r\n                }\r\n            },\r\n\r\n\r\n        }\r\n\r\n        const legendData = {\r\n            nodes: [{\r\n                    id: 'indus',\r\n                    label: `产业：${stats.industry + 48}`,\r\n\r\n                    ...typeConfigs['indus']\r\n                },\r\n                {\r\n                    id: 'technology',\r\n                    label: `技术：${stats.technology + 300}`,\r\n\r\n                    ...typeConfigs['technology']\r\n                }, {\r\n                    id: 'enterprise',\r\n                    label: `企业：${stats.enterprise + 300}`,\r\n\r\n                    ...typeConfigs['enterprise']\r\n                }, {\r\n                    id: 'patent',\r\n                    label: '专利：589',\r\n\r\n                    ...typeConfigs['patent']\r\n                },\r\n                {\r\n                    id: 'product',\r\n                    label: '产品：487',\r\n\r\n                    ...typeConfigs['product']\r\n                },\r\n\r\n\r\n            ],\r\n        }\r\n\r\n        const legend = new G6.Legend({\r\n            data: legendData,\r\n            align: 'center',\r\n            layout: 'vertical', // vertical\r\n            position: 'right-top',\r\n            vertiSep: 5,\r\n            horiSep: 5,\r\n            margin: 5,\r\n            offsetX: 2,\r\n            offsetY: 1,\r\n            padding: 16,\r\n\r\n            containerStyle: {\r\n                fill: 'rgba(220, 221, 225,0.5)',\r\n                opacity: 0.8,\r\n                lineWidth: 1,\r\n                radius: 30,\r\n\r\n            },\r\n\r\n            title: '图例',\r\n            titleConfig: {\r\n                position: 'center',\r\n                offsetX: 5,\r\n                offsetY: 10,\r\n\r\n            },\r\n\r\n            filter: {\r\n                enable: true,\r\n                multiple: true,\r\n                trigger: 'click',\r\n                graphActiveState: 'focus',\r\n\r\n                filterFunctions: {\r\n                    'technology': (d) => {\r\n                        if (d.category === '技术') return true;\r\n                        return false\r\n                    },\r\n                    'enterprise': (d) => {\r\n                        if (d.category === '企业') return true;\r\n                        return false\r\n                    },\r\n                    'patent': (d) => {\r\n                        if (d.category === '专利') return true;\r\n                        return false\r\n                    },\r\n                    'indus': (d) => {\r\n                        if (d.category === '产业') return true;\r\n                        return false\r\n                    },\r\n\r\n                }\r\n            }\r\n        });\r\n\r\n        // console.log(stats)\r\n\r\n        const container = document.getElementById('container');\r\n\r\n\r\n        container.style.backgroundColor = '#2b2f33';\r\n\r\n        CANVAS_WIDTH = container.scrollWidth - 20;\r\n        CANVAS_HEIGHT = (container.scrollHeight || 600) - 10;\r\n\r\n        nodeMap = {};\r\n        // 使用louvain算法对数据进行聚类，将结果存储到clusteredData中\r\n        /* const clusteredData = louvain(data, false, 'count'); */\r\n        const clusteredData = clusterByIndustry(data)\r\n\r\n        // 初始化一个聚合后的数据对象aggregatedData\r\n        const aggregatedData = { nodes: [], edges: [] };\r\n\r\n        // 遍历每个聚类，并将其中的节点加入到aggregatedData中\r\n        clusteredData.clusters.forEach((cluster, i) => {\r\n            // 遍历聚类中的每个节点\r\n            cluster.nodes.forEach((node) => {\r\n                // 对每个节点设置属性\r\n                node.level = 0;\r\n                node.orilabel = node.id;\r\n\r\n                node.label = formatText(node.orilabel, labelMaxLength, '...');\r\n\r\n                node.colorSet = colorSets[subjectMap[node.category]];\r\n                // 将节点对象存储到nodeMap中，key为节点id\r\n                nodeMap[node.id] = node;\r\n                node.isExpanded = false;\r\n                node.isNeighborShowed = false;\r\n            });\r\n            // 生成聚类产业节点inode\r\n            const inode = {\r\n                id: cluster.id,\r\n                category: '聚合节点',\r\n                count: cluster.nodes.length,\r\n                level: 1,\r\n                orilabel: clusterIdToIndustry[cluster.id],\r\n                label: clusterIdToIndustry[cluster.id],\r\n                colorSet: colorSets[subjectMap['聚合节点']],\r\n                idx: i,\r\n            };\r\n\r\n\r\n            // 将聚类节点对象存储到aggregatedNodeMap中，key为聚类id\r\n            aggregatedNodeMap[cluster.id] = inode;\r\n            // 将聚类节点对象存储到aggregatedData的节点数组中\r\n            aggregatedData.nodes.push(inode);\r\n\r\n        });\r\n\r\n        // 遍历聚类边，并将其加入到aggregatedData中\r\n        clusteredData.clusterEdges.forEach((clusterEdge) => {\r\n            // 生成聚类边对象cedge\r\n            const cedge = {\r\n                ...clusterEdge,\r\n                size: Math.log(clusterEdge.count),\r\n                label: '',\r\n                id: uniqueId('edge'),\r\n            };\r\n            // 判断是否为环\r\n            if (cedge.source === cedge.target) {\r\n                cedge.type = 'loop';\r\n                cedge.loopCfg = {\r\n                    dist: 20,\r\n                };\r\n            } else {\r\n                // 如果不是环，则设置为线性\r\n                cedge.type = 'line';\r\n            }\r\n            // 将聚类边对象存储到aggregatedData的边数组中\r\n            aggregatedData.edges.push(cedge);\r\n        });\r\n\r\n        // 对原始数据的边进行操作，设置label和id属性\r\n        data.edges.forEach((edge) => {\r\n\r\n            edge.id = `${edge.source}-${edge.target}`;\r\n        });\r\n\r\n        // 将聚合后的数据对象赋值给currentUnproccessedData\r\n        currentUnproccessedData = aggregatedData;\r\n\r\n        // 处理节点和边的位置，以适应当前画布大小\r\n        const { edges: processedEdges } = processNodesEdges(\r\n            currentUnproccessedData.nodes,\r\n            currentUnproccessedData.edges,\r\n            CANVAS_WIDTH,\r\n            CANVAS_HEIGHT,\r\n            largeGraphMode,\r\n            true,\r\n            true,\r\n        );\r\n\r\n        const contextMenu = new G6.Menu({\r\n            shouldBegin(evt) {\r\n                if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) return true;\r\n                if (evt.item) return true;\r\n                return false;\r\n            },\r\n            getContent(evt) {\r\n                const { item } = evt;\r\n                if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) {\r\n                    return `<ul>\r\n          <li id='show'>显示所有隐藏节点</li>\r\n          <li id='collapseAll'>折叠所有节点</li>\r\n        </ul>`;\r\n                } else if (!item) return;\r\n                const itemType = item.getType();\r\n                const model = item.getModel();\r\n                // console.log(model);\r\n                if (itemType && model) {\r\n                    if (itemType === 'node') {\r\n                        let html = `<ul>\r\n                        \r\n                            <li id='hide'>隐藏该节点</li>\r\n                          </ul>`;\r\n                        if (model.level !== 0) {\r\n                            html += `<ul>\r\n                            <li id='expand'>展开相关节点</li>\r\n                           \r\n                          </ul>`\r\n                            return html\r\n                        } else {\r\n                            let expandCollapseMenu;\r\n                            html += `<ul>\r\n                            <li id='collapse'>收缩该节点</li>\r\n                               \r\n                              </ul>`;\r\n\r\n                            if (model.category === \"技术\") {\r\n\r\n\r\n                                if (!model.isExpanded) {\r\n\r\n                                    html += `<ul>\r\n                                    <li id='neighbor-展开'>展开相关专利</li>\r\n                                   </ul>`;;\r\n\r\n\r\n\r\n                                } else html += `<ul>\r\n                                  <li id='neighbor-收缩'>收缩相关专利</li>\r\n                                 </ul>`;;\r\n\r\n                                return html;\r\n                            }\r\n                            if (model.category === \"企业\") {\r\n\r\n                                if (!model.isExpanded) {\r\n                                    html += `<ul>\r\n                                    <li id='neighbor-展开'>展开相关产品</li>\r\n                                   </ul>`;;\r\n                                } else html += `<ul>\r\n                                <li id='neighbor-收缩'>收缩相关产品</li>\r\n                               </ul>`;;\r\n\r\n                                return html;\r\n                            } else {\r\n\r\n                                return `<ul>\r\n                            <li id='collapse'>收缩节点</li>\r\n                            <li id='hide'>隐藏该节点</li>\r\n                          </ul>`;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        return `<ul>\r\n            <li id='hide'>隐藏该边</li>\r\n          </ul>`;\r\n                    }\r\n                }\r\n            },\r\n\r\n            handleMenuClick: (target, item) => {\r\n                const model = item && item.getModel();\r\n                const liIdStrs = target.id.split('-');\r\n                let mixedGraphData;\r\n                switch (liIdStrs[0]) {\r\n                    case 'return':\r\n                        graph.getNodes().forEach((item) => {\r\n                            if (item.getModel().id !== model.id) {\r\n                                if (item.getModel().category === '技术') graph.showItem(item);\r\n                                else {\r\n                                    graph.hideItem(item);\r\n                                    hiddenItemIds.push(model.id);\r\n                                }\r\n                            }\r\n                        });\r\n                    case 'hide':\r\n                        graph.hideItem(item);\r\n                        hiddenItemIds.push(model.id);\r\n                        break;\r\n                    case 'expand':\r\n\r\n                        const newArray = manageExpandCollapseArray(\r\n                            graph.getNodes().length,\r\n                            model,\r\n                            collapseArray,\r\n                            expandArray,\r\n                        );\r\n                        expandArray = newArray.expandArray;\r\n                        collapseArray = newArray.collapseArray;\r\n\r\n                        mixedGraphData = getMixedGraph(\r\n                            clusteredData,\r\n                            data,\r\n                            nodeMap,\r\n                            aggregatedNodeMap,\r\n                            expandArray,\r\n                            collapseArray,\r\n                        );\r\n\r\n                        break;\r\n                    case 'collapse':\r\n                        const aggregatedNode = aggregatedNodeMap[model.clusterId];\r\n\r\n                        manipulatePosition = { x: aggregatedNode.x, y: aggregatedNode.y };\r\n                        collapseArray.push(aggregatedNode);\r\n                        showItems(graph);\r\n                        for (let i = 0; i < expandArray.length; i++) {\r\n                            if (expandArray[i].id === model.clusterId) {\r\n                                expandArray.splice(i, 1);\r\n                                break;\r\n                            }\r\n                        }\r\n                        mixedGraphData = getMixedGraph(\r\n                            clusteredData,\r\n                            data,\r\n                            nodeMap,\r\n                            aggregatedNodeMap,\r\n                            expandArray,\r\n                            collapseArray,\r\n                        );\r\n                        break;\r\n                    case 'collapseAll':\r\n                        expandArray = [];\r\n                        collapseArray = [];\r\n                        mixedGraphData = getMixedGraph(\r\n                            clusteredData,\r\n                            data,\r\n                            nodeMap,\r\n                            aggregatedNodeMap,\r\n                            expandArray,\r\n                            collapseArray,\r\n                        );\r\n                        showItems(graph);\r\n                        break;\r\n                    case 'neighbor':\r\n                        const neighborNodes = item.getNeighbors();\r\n                        const expandNeighborType = model.category === '技术' ? '专利' : '产品';\r\n                        if (model.isNeighborShowed === false)\r\n\r\n                            mixedGraphData = getNeighborMixedGraph(\r\n                            model,\r\n                            expandNeighborType,\r\n                            data,\r\n                            clusteredData,\r\n                            currentUnproccessedData,\r\n                            nodeMap,\r\n                            aggregatedNodeMap,\r\n                            10,\r\n                        );\r\n                        model.isNeighborShowed = true;\r\n                        if (liIdStrs[1] === '展开') {\r\n                            neighborNodes.forEach((item) => {\r\n                                if (item.getModel().category !== '产业') {\r\n                                    graph.showItem(item);\r\n\r\n                                }\r\n                            })\r\n\r\n\r\n                        } else if (liIdStrs[1] === '收缩') {\r\n\r\n                            console.log(neighborNodes);\r\n                            neighborNodes.forEach((item) => {\r\n                                if (item.getModel().category !== '产业') {\r\n                                    graph.hideItem(item);\r\n                                    hiddenItemIds.push(item.getModel().id);\r\n                                }\r\n                            })\r\n\r\n                        }\r\n                        graph.getNodes().forEach((item) => {\r\n                            if (item.getModel().level) {\r\n                                if (item.getModel().id !== model.id) {\r\n                                    graph.hideItem(item);\r\n                                    hiddenItemIds.push(item.getModel().id);\r\n                                }\r\n                            }\r\n                        });\r\n\r\n\r\n\r\n\r\n\r\n                        model.isExpanded = !model.isExpanded;\r\n\r\n\r\n\r\n\r\n                        break;\r\n                    case 'show':\r\n                        showItems(graph);\r\n\r\n\r\n\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n                if (mixedGraphData) {\r\n                    cachePositions = cacheNodePositions(graph.getNodes());\r\n                    currentUnproccessedData = mixedGraphData;\r\n                    handleRefreshGraph(\r\n                        graph,\r\n                        currentUnproccessedData,\r\n                        CANVAS_WIDTH,\r\n                        CANVAS_HEIGHT,\r\n                        largeGraphMode,\r\n                        true,\r\n                        false,\r\n                    );\r\n                }\r\n            },\r\n            // offsetX and offsetY include the padding of the parent container\r\n            // 需要加上父级容器的 padding-left 16 与自身偏移量 10\r\n            offsetX: 16 + 10,\r\n            // 需要加上父级容器的 padding-top 24 、画布兄弟元素高度、与自身偏移量 10\r\n            offsetY: 0,\r\n            // the types of items that allow the menu show up\r\n            // 在哪些类型的元素上响应\r\n            itemTypes: ['node', 'edge', 'canvas'],\r\n        });\r\n\r\n        graph = new G6.Graph({\r\n            container: 'container',\r\n            width: CANVAS_WIDTH,\r\n            height: CANVAS_HEIGHT,\r\n            linkCenter: true,\r\n            minZoom: 0.1,\r\n\r\n            modes: {\r\n                default: [{\r\n                        type: 'drag-canvas',\r\n                        enableOptimize: true,\r\n                    },\r\n                    {\r\n                        type: 'zoom-canvas',\r\n                        enableOptimize: true,\r\n                        optimizeZoom: 0.01,\r\n                    }, {\r\n                        type: 'scroll-canvas',\r\n                        direction: 'both',\r\n                        enableOptimize: true,\r\n                        zoomKey: 'ctrl',\r\n                        scalableRange: -0.3\r\n                    },\r\n                    {\r\n                        type: 'lasso-select',\r\n                        selectedState: 'focus',\r\n                        trigger: 'shift',\r\n                    },\r\n                    'drag-node',\r\n                    'shortcuts-call',\r\n                ],\r\n\r\n            },\r\n\r\n            plugins: [contextMenu, grid, tooltip, legend, ],\r\n        });\r\n\r\n\r\n        const layoutConfig = getForceLayoutConfig(graph, largeGraphMode);\r\n        layoutConfig.center = [CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2];\r\n        layout.instance = new G6.Layout['gForce'](layoutConfig);\r\n        layout.instance.init({\r\n            nodes: currentUnproccessedData.nodes,\r\n            edges: processedEdges,\r\n        });\r\n        layout.instance.execute();\r\n\r\n        bindListener(graph);\r\n        graph.data({ nodes: aggregatedData.nodes, edges: processedEdges });\r\n        graph.render();\r\n\r\n    })\r\n    // 遍历所有节点\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof window !== 'undefined')\r\n    window.onresize = () => {\r\n        if (!graph || graph.get('destroyed')) return;\r\n        const container = document.getElementById('container');\r\n        if (!container) return;\r\n        graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\r\n    };","export const grid = new G6.Grid();\r\n\r\n// 添加一个搜索框\r\nconst searchInput = document.createElement('input');\r\nsearchInput.type = 'text';\r\ndocument.body.appendChild(searchInput);\r\n\r\n// 定义搜索函数\r\nfunction searchNodeByLabel(label) {\r\n    // 查找所有带有指定标签的节点\r\n    const nodes = graph.findAll('node', node => node.getModel().label === label);\r\n    // 高亮显示这些节点\r\n    graph.highlightNodes(nodes.map(node => node.getID()));\r\n}\r\n\r\n// 绑定搜索框事件\r\nsearchInput.addEventListener('input', (event) => {\r\n    const label = event.target.value;\r\n    // 调用搜索函数\r\n    searchNodeByLabel(label);\r\n});\r\nexport const tooltip = new G6.Tooltip({\r\n    offsetX: 20,\r\n    offsetY: 20,\r\n    getContent(e) {\r\n        const outDiv = document.createElement('div')\r\n        outDiv.style.width = 'auto'\r\n        outDiv.innerHTML = `\r\n<ul>\r\n<li><span class=\"label\">名称:</span> <span class=\"value\">${e.item.getModel().label}</span></li>\r\n<li><span class=\"label\">类型:</span> <span class=\"value\">${e.item.getModel().category}</span></li>\r\n</ul>`\r\n        return outDiv\r\n    },\r\n    itemTypes: ['node']\r\n})\r\n\r\n\r\n\r\n\r\n"],"names":["$e87b787498170b8e$var$descreteNodeCenter","$e87b787498170b8e$var$manipulatePosition","$f030692716f7b8a2$export$85fc379452d91af0","G6","Grid","$f030692716f7b8a2$var$searchInput","document","createElement","type","body","appendChild","addEventListener","event","$f030692716f7b8a2$var$searchNodeByLabel","label","nodes","graph","findAll","node","getModel","highlightNodes","map","getID","target","value","$f030692716f7b8a2$export$4e6f96734dfe12f4","Tooltip","offsetX","offsetY","getContent","e","outDiv","style","width","innerHTML","item","category","itemTypes","$e87b787498170b8e$var$searchInput","getElementById","$e87b787498170b8e$var$searchButton","$e87b787498170b8e$var$candidateList","className","$e87b787498170b8e$var$searchWrapper","querySelector","keyword","$e87b787498170b8e$var$graph","orilabel","includes","length","count","console","warn","forEach","setItemState","focusItem","alert","log","candidate","display","key","uniqueId","$e87b787498170b8e$var$uniqueId","Util","$e87b787498170b8e$var$currentUnproccessedData","edges","$e87b787498170b8e$var$nodeMap","$e87b787498170b8e$var$aggregatedNodeMap","$e87b787498170b8e$var$hiddenItemIds","$e87b787498170b8e$var$cachePositions","$e87b787498170b8e$var$layout","instance","$e87b787498170b8e$var$expandArray","$e87b787498170b8e$var$collapseArray","$e87b787498170b8e$var$shiftKeydown","$e87b787498170b8e$var$CANVAS_WIDTH","$e87b787498170b8e$var$CANVAS_HEIGHT","$e87b787498170b8e$var$colorSets","getColorSetsBySubjectColors","$e87b787498170b8e$var$global","fill","labelCfg","stroke","stateStyles","focus","selected","lineWidth","strokeOpacity","activeByLegend","inactiveByLegend","opacity","edge","realEdgeStroke","realEdgeOpacity","registerNode","draw","cfg","group","height","colorSet","addShape","attrs","x","y","mainFill","radius","name","visible","lineOpacty","keyShape","mainStroke","cursor","lineDash","labelStyle","Object","assign","text","textAlign","textBaseline","fontSize","fontWeight","draggable","new","r","setState","get","labelShape","find","set","hasState","halo","getKeyShape","show","attr","activeFill","hide","selectedFill","update","undefined","degreeSum","degree","refY","lineNum","labelLineNum","textBaseLine","registerEdge","model","back","ele","stopAnimate","remove","destroy","arrow","endArrow","animation","isReal","path","toBack","getTotalLength","animate","ratio","startLen","repeat","duration","index","totalLength","lineDashOffset","$e87b787498170b8e$var$descendCompare","p","m","n","a","b","$e87b787498170b8e$var$clearFocusItemState","$e87b787498170b8e$var$clearFocusNodeState","$e87b787498170b8e$var$clearFocusEdgeState","focusNodes","findAllByState","fnode","focusEdges","fedge","$e87b787498170b8e$var$formatText","elipsis","substr","$e87b787498170b8e$var$labelFormatter","minLength","split","$e87b787498170b8e$var$processNodesEdges","largeGraphMode","edgeLabelVisible","isNewGraph","currentNodeMap","maxNodeCount","Infinity","level","inDegree","outDegree","id","Math","random","cachePosition","cos","PI","sin","maxCount","minCount","source","sourceNode","targetNode","sort","maxDegree","descreteNodes","countRatio","isRealNode","size","position","offset","push","countRange","maxEdgeSize","arrowWidth","max","arrowBeging","arrowPath","d","isRealEdge","dash","lineAppendWidth","fillOpacity","autoRotate","sourceDis","targetDis","paddingRatio","processParallelEdges","$e87b787498170b8e$var$getForceLayoutConfig","configSettings","linkDistance","edgeStrength","nodeStrength","nodeSpacing","preventOverlap","nodeSize","collideStrength","alpha","alphaDecay","alphaMin","config","minMovement","maxIteration","damping","dist","onLayoutEnd","getEdges","tick","refreshPositions","$e87b787498170b8e$var$hideItems","hideItem","$e87b787498170b8e$var$showItems","getNodes","isVisible","showItem","$e87b787498170b8e$var$handleRefreshGraph","graphData","processRes","changeData","toFront","init","getMass","execute","$e87b787498170b8e$var$getMixedGraph","aggregatedData","originData","nodeMap","aggregatedNodeMap","expandArray","collapseArray","expandMap","collapseMap","expandModel","collapseModel","clusters","cluster","i","concat","expanded","isSourceInExpandArray","clusterId","isTargetInExpandArray","targetClusterId","vedge","sourceClusterId","clusterEdges","$e87b787498170b8e$var$examAncestors","expandedArray","keepTags","expandedNode","parentId","$e87b787498170b8e$var$manageExpandCollapseArray","nodeNumber","expandLen","shiftNodeIdx","collapseNodeId","foundNode","foundLevel1","eNode","splice","idSplits","str","collapseNode","currentNode","setCursor","$e87b787498170b8e$var$cacheNodePositions","positionMap","nodeLength","$e87b787498170b8e$var$stopLayout","stop","$e87b787498170b8e$var$bindListener","on","evt","code","toLowerCase","currentLabel","oriFontSize","getSource","getTarget","relatedEdges","relatedNodes","getNeighbors","filter","getGroup","getBBox","getCanvasBBox","$e87b787498170b8e$var$subjectMap","$e87b787498170b8e$var$industryToClusterId","$e87b787498170b8e$var$clusterIdToIndustry","industry","$e87b787498170b8e$var$getNeighborMixedGraph","centerNodeModel","neighborType","clusteredData","currentData","maxNeighborNumPerNode","neighborSubGraph","$e87b787498170b8e$var$generateNeighbors","sumTot","newNodes","some","newEdges","centerId","neighborNum","ceil","neighborNode","generateRandomPatentName","products","floor","neighborEdge","Promise","all","$e87b787498170b8e$var$filenames","filename","fetch","then","response","json","dataArr","data","reduce","acc","stats","technology","enterprise","legendData","stoke","legend","Legend","align","layout","vertiSep","horiSep","margin","padding","containerStyle","title","titleConfig","enable","multiple","trigger","graphActiveState","filterFunctions","container","backgroundColor","scrollWidth","scrollHeight","$e87b787498170b8e$var$clusterByIndustry","industryMap","Map","belongsto","has","Array","from","values","edgeMap","edgeKey","reverseEdgeKey","isExpanded","isNeighborShowed","inode","idx","clusterEdge","cedge","loopCfg","processedEdges","contextMenu","Menu","shouldBegin","isCanvas","itemType","getType","html","handleMenuClick","mixedGraphData","liIdStrs","newArray","aggregatedNode","neighborNodes","expandNeighborType","layoutConfig","Graph","linkCenter","minZoom","modes","default","enableOptimize","optimizeZoom","direction","zoomKey","scalableRange","selectedState","plugins","center","Layout","render","window","onresize","changeSize"],"version":3,"file":"index.c46b125a.js.map"}